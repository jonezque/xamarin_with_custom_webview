"use strict"; (self.webpackChunkang_elf_app = self.webpackChunkang_elf_app || []).push([[179], { 969: () => { function ee(t) { return "function" == typeof t } function xo(t) { const n = t(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const No = xo(t => function (n) { t(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, i) => `${i + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function wr(t, e) { if (t) { const n = t.indexOf(e); 0 <= n && t.splice(n, 1) } } class kt { constructor(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let e; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const o of n) o.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (ee(r)) try { r() } catch (o) { e = o instanceof No ? o.errors : [o] } const { _finalizers: i } = this; if (i) { this._finalizers = null; for (const o of i) try { _f(o) } catch (s) { e = e ?? [], s instanceof No ? e = [...e, ...s.errors] : e.push(s) } } if (e) throw new No(e) } } add(e) { var n; if (e && e !== this) if (this.closed) _f(e); else { if (e instanceof kt) { if (e.closed || e._hasParent(this)) return; e._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(e) } } _hasParent(e) { const { _parentage: n } = this; return n === e || Array.isArray(n) && n.includes(e) } _addParent(e) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e } _removeParent(e) { const { _parentage: n } = this; n === e ? this._parentage = null : Array.isArray(n) && wr(n, e) } remove(e) { const { _finalizers: n } = this; n && wr(n, e), e instanceof kt && e._removeParent(this) } } kt.EMPTY = (() => { const t = new kt; return t.closed = !0, t })(); const gf = kt.EMPTY; function yf(t) { return t instanceof kt || t && "closed" in t && ee(t.remove) && ee(t.add) && ee(t.unsubscribe) } function _f(t) { ee(t) ? t() : t.unsubscribe() } const Zn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, ko = { setTimeout(t, e, ...n) { const { delegate: r } = ko; return r?.setTimeout ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n) }, clearTimeout(t) { const { delegate: e } = ko; return (e?.clearTimeout || clearTimeout)(t) }, delegate: void 0 }; function vf(t) { ko.setTimeout(() => { const { onUnhandledError: e } = Zn; if (!e) throw t; e(t) }) } function Ya() { } const BD = Xa("C", void 0, void 0); function Xa(t, e, n) { return { kind: t, value: e, error: n } } let Yn = null; function Oo(t) { if (Zn.useDeprecatedSynchronousErrorHandling) { const e = !Yn; if (e && (Yn = { errorThrown: !1, error: null }), t(), e) { const { errorThrown: n, error: r } = Yn; if (Yn = null, n) throw r } } else t() } class Ja extends kt { constructor(e) { super(), this.isStopped = !1, e ? (this.destination = e, yf(e) && e.add(this)) : this.destination = qD } static create(e, n, r) { return new Po(e, n, r) } next(e) { this.isStopped ? tl(function HD(t) { return Xa("N", t, void 0) }(e), this) : this._next(e) } error(e) { this.isStopped ? tl(function jD(t) { return Xa("E", void 0, t) }(e), this) : (this.isStopped = !0, this._error(e)) } complete() { this.isStopped ? tl(BD, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(e) { this.destination.next(e) } _error(e) { try { this.destination.error(e) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const UD = Function.prototype.bind; function el(t, e) { return UD.call(t, e) } class GD { constructor(e) { this.partialObserver = e } next(e) { const { partialObserver: n } = this; if (n.next) try { n.next(e) } catch (r) { Ro(r) } } error(e) { const { partialObserver: n } = this; if (n.error) try { n.error(e) } catch (r) { Ro(r) } else Ro(e) } complete() { const { partialObserver: e } = this; if (e.complete) try { e.complete() } catch (n) { Ro(n) } } } class Po extends Ja { constructor(e, n, r) { let i; if (super(), ee(e) || !e) i = { next: e ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let o; this && Zn.useDeprecatedNextContext ? (o = Object.create(e), o.unsubscribe = () => this.unsubscribe(), i = { next: e.next && el(e.next, o), error: e.error && el(e.error, o), complete: e.complete && el(e.complete, o) }) : i = e } this.destination = new GD(i) } } function Ro(t) { Zn.useDeprecatedSynchronousErrorHandling ? function $D(t) { Zn.useDeprecatedSynchronousErrorHandling && Yn && (Yn.errorThrown = !0, Yn.error = t) }(t) : vf(t) } function tl(t, e) { const { onStoppedNotification: n } = Zn; n && ko.setTimeout(() => n(t, e)) } const qD = { closed: !0, next: Ya, error: function zD(t) { throw t }, complete: Ya }, nl = "function" == typeof Symbol && Symbol.observable || "@@observable"; function rl(t) { return t } let Pe = (() => { class t { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new t; return r.source = this, r.operator = n, r } subscribe(n, r, i) { const o = function KD(t) { return t && t instanceof Ja || function WD(t) { return t && ee(t.next) && ee(t.error) && ee(t.complete) }(t) && yf(t) }(n) ? n : new Po(n, r, i); return Oo(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Df(r))((i, o) => { const s = new Po({ next: a => { try { n(a) } catch (l) { o(l), s.unsubscribe() } }, error: o, complete: i }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [nl]() { return this } pipe(...n) { return function bf(t) { return 0 === t.length ? rl : 1 === t.length ? t[0] : function (n) { return t.reduce((r, i) => i(r), n) } }(n)(this) } toPromise(n) { return new (n = Df(n))((r, i) => { let o; this.subscribe(s => o = s, s => i(s), () => r(o)) }) } } return t.create = e => new t(e), t })(); function Df(t) { var e; return null !== (e = t ?? Zn.Promise) && void 0 !== e ? e : Promise } const QD = xo(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let Ot = (() => { class t extends Pe { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Ef(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new QD } next(n) { Oo(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { Oo(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { Oo(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: i, observers: o } = this; return r || i ? gf : (this.currentObservers = null, o.push(n), new kt(() => { this.currentObservers = null, wr(o, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: i, isStopped: o } = this; r ? n.error(i) : o && n.complete() } asObservable() { const n = new Pe; return n.source = this, n } } return t.create = (e, n) => new Ef(e, n), t })(); class Ef extends Ot { constructor(e, n) { super(), this.destination = e, this.source = n } next(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, e) } error(e) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, e) } complete() { var e, n; null === (n = null === (e = this.destination) || void 0 === e ? void 0 : e.complete) || void 0 === n || n.call(e) } _subscribe(e) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(e)) && void 0 !== r ? r : gf } } function Pt(t) { return e => { if (function ZD(t) { return ee(t?.lift) }(e)) return e.lift(function (n) { try { return t(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Yt(t, e, n, r, i) { return new YD(t, e, n, r, i) } class YD extends Ja { constructor(e, n, r, i, o, s) { super(e), this.onFinalize = o, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (l) { e.error(l) } } : super._next, this._error = i ? function (a) { try { i(a) } catch (l) { e.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { e.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var e; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (e = this.onFinalize) || void 0 === e || e.call(this)) } } } function il(t, e) { return Pt((n, r) => { let i = 0; n.subscribe(Yt(r, o => { r.next(t.call(e, o, i++)) })) }) } function Xn(t) { return this instanceof Xn ? (this.v = t, this) : new Xn(t) } function eE(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, r = n.apply(t, e || []), o = []; return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function () { return this }, i; function s(f) { r[f] && (i[f] = function (h) { return new Promise(function (p, m) { o.push([f, h, p, m]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function l(f) { f.value instanceof Xn ? Promise.resolve(f.value.v).then(u, c) : d(o[0][2], f) }(r[f](h)) } catch (p) { d(o[0][3], p) } } function u(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), o.shift(), o.length && a(o[0][0], o[0][1]) } } function tE(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, e = t[Symbol.asyncIterator]; return e ? e.call(t) : (t = function Mf(t) { var e = "function" == typeof Symbol && Symbol.iterator, n = e && t[e], r = 0; if (n) return n.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(o) { n[o] = t[o] && function (s) { return new Promise(function (a, l) { !function i(o, s, a, l) { Promise.resolve(l).then(function (u) { o({ value: u, done: a }) }, s) }(a, l, (s = t[o](s)).done, s.value) }) } } } const sl = t => t && "number" == typeof t.length && "function" != typeof t; function Af(t) { return ee(t?.then) } function Tf(t) { return ee(t[nl]) } function If(t) { return Symbol.asyncIterator && ee(t?.[Symbol.asyncIterator]) } function Sf(t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Ff = function rE() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function xf(t) { return ee(t?.[Ff]) } function Nf(t) { return eE(this, arguments, function* () { const n = t.getReader(); try { for (; ;) { const { value: r, done: i } = yield Xn(n.read()); if (i) return yield Xn(void 0); yield yield Xn(r) } } finally { n.releaseLock() } }) } function kf(t) { return ee(t?.getReader) } function _n(t) { if (t instanceof Pe) return t; if (null != t) { if (Tf(t)) return function iE(t) { return new Pe(e => { const n = t[nl](); if (ee(n.subscribe)) return n.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(t); if (sl(t)) return function oE(t) { return new Pe(e => { for (let n = 0; n < t.length && !e.closed; n++)e.next(t[n]); e.complete() }) }(t); if (Af(t)) return function sE(t) { return new Pe(e => { t.then(n => { e.closed || (e.next(n), e.complete()) }, n => e.error(n)).then(null, vf) }) }(t); if (If(t)) return Of(t); if (xf(t)) return function aE(t) { return new Pe(e => { for (const n of t) if (e.next(n), e.closed) return; e.complete() }) }(t); if (kf(t)) return function lE(t) { return Of(Nf(t)) }(t) } throw Sf(t) } function Of(t) { return new Pe(e => { (function uE(t, e) { var n, r, i, o; return function XD(t, e, n, r) { return new (n || (n = Promise))(function (o, s) { function a(c) { try { u(r.next(c)) } catch (d) { s(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? o(c.value) : function i(o) { return o instanceof n ? o : new n(function (s) { s(o) }) }(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = tE(t); !(r = yield n.next()).done;)if (e.next(r.value), e.closed) return } catch (s) { i = { error: s } } finally { try { r && !r.done && (o = n.return) && (yield o.call(n)) } finally { if (i) throw i.error } } e.complete() }) })(t, e).catch(n => e.error(n)) }) } function Nn(t, e, n, r = 0, i = !1) { const o = e.schedule(function () { n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (t.add(o), !i) return o } function al(t, e, n = 1 / 0) { return ee(e) ? al((r, i) => il((o, s) => e(r, o, i, s))(_n(t(r, i))), n) : ("number" == typeof e && (n = e), Pt((r, i) => function cE(t, e, n, r, i, o, s, a) { const l = []; let u = 0, c = 0, d = !1; const f = () => { d && !l.length && !u && e.complete() }, h = m => u < r ? p(m) : l.push(m), p = m => { o && e.next(m), u++; let y = !1; _n(n(m, c++)).subscribe(Yt(e, _ => { i?.(_), o ? h(_) : e.next(_) }, () => { y = !0 }, void 0, () => { if (y) try { for (u--; l.length && u < r;) { const _ = l.shift(); s ? Nn(e, s, () => p(_)) : p(_) } f() } catch (_) { e.error(_) } })) }; return t.subscribe(Yt(e, h, () => { d = !0, f() })), () => { a?.() } }(r, i, t, n))) } function Pf(t = 1 / 0) { return al(rl, t) } const Lo = new Pe(t => t.complete()); function ll(t) { return t[t.length - 1] } function Vo(t) { return function fE(t) { return t && ee(t.schedule) }(ll(t)) ? t.pop() : void 0 } function Rf(t, e = 0) { return Pt((n, r) => { n.subscribe(Yt(r, i => Nn(r, t, () => r.next(i), e), () => Nn(r, t, () => r.complete(), e), i => Nn(r, t, () => r.error(i), e))) }) } function Lf(t, e = 0) { return Pt((n, r) => { r.add(t.schedule(() => n.subscribe(r), e)) }) } function Vf(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new Pe(n => { Nn(n, e, () => { const r = t[Symbol.asyncIterator](); Nn(n, e, () => { r.next().then(i => { i.done ? n.complete() : n.next(i.value) }) }, 0, !0) }) }) } function vi(t, e) { return e ? function bE(t, e) { if (null != t) { if (Tf(t)) return function mE(t, e) { return _n(t).pipe(Lf(e), Rf(e)) }(t, e); if (sl(t)) return function yE(t, e) { return new Pe(n => { let r = 0; return e.schedule(function () { r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule()) }) }) }(t, e); if (Af(t)) return function gE(t, e) { return _n(t).pipe(Lf(e), Rf(e)) }(t, e); if (If(t)) return Vf(t, e); if (xf(t)) return function _E(t, e) { return new Pe(n => { let r; return Nn(n, e, () => { r = t[Ff](), Nn(n, e, () => { let i, o; try { ({ value: i, done: o } = r.next()) } catch (s) { return void n.error(s) } o ? n.complete() : n.next(i) }, 0, !0) }), () => ee(r?.return) && r.return() }) }(t, e); if (kf(t)) return function vE(t, e) { return Vf(Nf(t), e) }(t, e) } throw Sf(t) }(t, e) : _n(t) } function Bf(...t) { const e = Vo(t), n = function pE(t, e) { return "number" == typeof ll(t) ? t.pop() : e }(t, 1 / 0), r = t; return r.length ? 1 === r.length ? _n(r[0]) : Pf(n)(vi(r, e)) : Lo } function jf(t) { return t <= 0 ? () => Lo : Pt((e, n) => { let r = 0; e.subscribe(Yt(n, i => { ++r <= t && (n.next(i), t <= r && n.complete()) })) }) } function ul(t, e, ...n) { return !0 === e ? (t(), null) : !1 === e ? null : e(...n).pipe(jf(1)).subscribe(() => t()) } function re(t) { for (let e in t) if (t[e] === re) return e; throw Error("Could not find renamed property on target object.") } function cl(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function ie(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(ie).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function dl(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const EE = re({ __forward_ref__: re }); function se(t) { return t.__forward_ref__ = se, t.toString = function () { return ie(this()) }, t } function P(t) { return fl(t) ? t() : t } function fl(t) { return "function" == typeof t && t.hasOwnProperty(EE) && t.__forward_ref__ === se } class w extends Error { constructor(e, n) { super(function Bo(t, e) { return `NG0${Math.abs(t)}${e ? ": " + e : ""}` }(e, n)), this.code = e } } function V(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function jo(t, e) { throw new w(-201, !1) } function lt(t, e) { null == t && function te(t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${e} <=Actual]`)) }(e, t, null, "!=") } function G(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function xe(t) { return { providers: t.providers || [], imports: t.imports || [] } } function hl(t) { return Hf(t, Ho) || Hf(t, Uf) } function Hf(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function $f(t) { return t && (t.hasOwnProperty(pl) || t.hasOwnProperty(FE)) ? t[pl] : null } const Ho = re({ \u0275prov: re }), pl = re({ \u0275inj: re }), Uf = re({ ngInjectableDef: re }), FE = re({ ngInjectorDef: re }); var R = (() => ((R = R || {})[R.Default = 0] = "Default", R[R.Host = 1] = "Host", R[R.Self = 2] = "Self", R[R.SkipSelf = 4] = "SkipSelf", R[R.Optional = 8] = "Optional", R))(); let ml; function Xt(t) { const e = ml; return ml = t, e } function Gf(t, e, n) { const r = hl(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & R.Optional ? null : void 0 !== e ? e : void jo(ie(t)) } function kn(t) { return { toString: t }.toString() } var Rt = (() => ((Rt = Rt || {})[Rt.OnPush = 0] = "OnPush", Rt[Rt.Default = 1] = "Default", Rt))(), Lt = (() => { return (t = Lt || (Lt = {}))[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", Lt; var t })(); const ne = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), Cr = {}, J = [], $o = re({ \u0275cmp: re }), gl = re({ \u0275dir: re }), yl = re({ \u0275pipe: re }), zf = re({ \u0275mod: re }), bn = re({ \u0275fac: re }), bi = re({ __NG_ELEMENT_ID__: re }); let NE = 0; function Di(t) { return kn(() => { const n = !0 === t.standalone, r = {}, i = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: r, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Rt.OnPush, directiveDefs: null, pipeDefs: null, standalone: n, dependencies: n && t.dependencies || null, getStandaloneInjector: null, selectors: t.selectors || J, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || Lt.Emulated, id: "c", styles: t.styles || J, _: null, setInput: null, schemas: t.schemas || null, tView: null }, o = t.dependencies, s = t.features; return i.id += NE++, i.inputs = Kf(t.inputs, r), i.outputs = Kf(t.outputs), s && s.forEach(a => a(i)), i.directiveDefs = o ? () => ("function" == typeof o ? o() : o).map(qf).filter(Wf) : null, i.pipeDefs = o ? () => ("function" == typeof o ? o() : o).map(Ke).filter(Wf) : null, i }) } function qf(t) { return oe(t) || We(t) } function Wf(t) { return null !== t } const OE = {}; function Re(t) { return kn(() => { const e = { type: t.type, bootstrap: t.bootstrap || J, declarations: t.declarations || J, imports: t.imports || J, exports: t.exports || J, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (OE[t.id] = t.type), e }) } function Kf(t, e) { if (null == t) return Cr; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let i = t[r], o = i; Array.isArray(i) && (o = i[1], i = i[0]), n[i] = r, e && (e[i] = o) } return n } const N = Di; function oe(t) { return t[$o] || null } function We(t) { return t[gl] || null } function Ke(t) { return t[yl] || null } const $ = 11; function rt(t) { return Array.isArray(t) && "object" == typeof t[1] } function Bt(t) { return Array.isArray(t) && !0 === t[1] } function bl(t) { return 0 != (8 & t.flags) } function qo(t) { return 2 == (2 & t.flags) } function Wo(t) { return 1 == (1 & t.flags) } function jt(t) { return null !== t.template } function BE(t) { return 0 != (256 & t[2]) } function rr(t, e) { return t.hasOwnProperty(bn) ? t[bn] : null } class $E { constructor(e, n, r) { this.previousValue = e, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function Jt() { return Yf } function Yf(t) { return t.type.prototype.ngOnChanges && (t.setInput = GE), UE } function UE() { const t = Jf(this), e = t?.current; if (e) { const n = t.previous; if (n === Cr) t.previous = e; else for (let r in e) n[r] = e[r]; t.current = null, this.ngOnChanges(e) } } function GE(t, e, n, r) { const i = Jf(t) || function zE(t, e) { return t[Xf] = e }(t, { previous: Cr, current: null }), o = i.current || (i.current = {}), s = i.previous, a = this.declaredInputs[n], l = s[a]; o[a] = new $E(l && l.currentValue, e, s === Cr), t[r] = e } Jt.ngInherit = !0; const Xf = "__ngSimpleChanges__"; function Jf(t) { return t[Xf] || null } let Ml; function _e(t) { return !!t.listen } const eh = { createRenderer: (t, e) => function Al() { return void 0 !== Ml ? Ml : typeof document < "u" ? document : void 0 }() }; function we(t) { for (; Array.isArray(t);)t = t[0]; return t } function Ko(t, e) { return we(e[t]) } function Ct(t, e) { return we(e[t.index]) } function Tl(t, e) { return t.data[e] } function dt(t, e) { const n = e[t]; return rt(n) ? n : n[0] } function th(t) { return 4 == (4 & t[2]) } function Il(t) { return 64 == (64 & t[2]) } function On(t, e) { return null == e ? null : t[e] } function nh(t) { t[18] = 0 } function Sl(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const L = { lFrame: dh(null), bindingsEnabled: !0 }; function ih() { return L.bindingsEnabled } function b() { return L.lFrame.lView } function K() { return L.lFrame.tView } function Fl(t) { return L.lFrame.contextLView = t, t[8] } function xl(t) { return L.lFrame.contextLView = null, t } function Te() { let t = oh(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function oh() { return L.lFrame.currentTNode } function en(t, e) { const n = L.lFrame; n.currentTNode = t, n.isParent = e } function Nl() { return L.lFrame.isParent } function kl() { L.lFrame.isParent = !1 } function Fr() { return L.lFrame.bindingIndex++ } function lw(t, e) { const n = L.lFrame; n.bindingIndex = n.bindingRootIndex = t, Ol(e) } function Ol(t) { L.lFrame.currentDirectiveIndex = t } function lh() { return L.lFrame.currentQueryIndex } function Rl(t) { L.lFrame.currentQueryIndex = t } function cw(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function uh(t, e, n) { if (n & R.SkipSelf) { let i = e, o = t; for (; !(i = i.parent, null !== i || n & R.Host || (i = cw(o), null === i || (o = o[15], 10 & i.type)));); if (null === i) return !1; e = i, t = o } const r = L.lFrame = ch(); return r.currentTNode = e, r.lView = t, !0 } function Zo(t) { const e = ch(), n = t[1]; L.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function ch() { const t = L.lFrame, e = null === t ? null : t.child; return null === e ? dh(t) : e } function dh(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function fh() { const t = L.lFrame; return L.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const hh = fh; function Yo() { const t = fh(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function Ye() { return L.lFrame.selectedIndex } function Pn(t) { L.lFrame.selectedIndex = t } function ve() { const t = L.lFrame; return Tl(t.tView, t.selectedIndex) } function Xo(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const o = t.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = o; s && (t.contentHooks || (t.contentHooks = [])).push(-n, s), a && ((t.contentHooks || (t.contentHooks = [])).push(n, a), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, a)), l && (t.viewHooks || (t.viewHooks = [])).push(-n, l), u && ((t.viewHooks || (t.viewHooks = [])).push(n, u), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, u)), null != c && (t.destroyHooks || (t.destroyHooks = [])).push(n, c) } } function Jo(t, e, n) { ph(t, e, 3, n) } function es(t, e, n, r) { (3 & t[2]) === n && ph(t, e, n, r) } function Ll(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function ph(t, e, n, r) { const o = r ?? -1, s = e.length - 1; let a = 0; for (let l = void 0 !== r ? 65535 & t[18] : 0; l < s; l++)if ("number" == typeof e[l + 1]) { if (a = e[l], null != r && a >= r) break } else e[l] < 0 && (t[18] += 65536), (a < o || -1 == o) && (vw(t, n, e, l), t[18] = (4294901760 & t[18]) + l + 2), l++ } function vw(t, e, n, r) { const i = n[r] < 0, o = n[r + 1], a = t[i ? -n[r] : n[r]]; if (i) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { o.call(a) } finally { } } } else try { o.call(a) } finally { } } class Ai { constructor(e, n, r) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function ts(t, e, n) { const r = _e(t); let i = 0; for (; i < n.length;) { const o = n[i]; if ("number" == typeof o) { if (0 !== o) break; i++; const s = n[i++], a = n[i++], l = n[i++]; r ? t.setAttribute(e, a, l, s) : e.setAttributeNS(s, a, l) } else { const s = o, a = n[++i]; Bl(s) ? r && t.setProperty(e, s, a) : r ? t.setAttribute(e, s, a) : e.setAttribute(s, a), i++ } } return i } function mh(t) { return 3 === t || 4 === t || 6 === t } function Bl(t) { return 64 === t.charCodeAt(0) } function ns(t, e) { if (null !== e && 0 !== e.length) if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const i = e[r]; "number" == typeof i ? n = i : 0 === n || gh(t, n, i, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function gh(t, e, n, r, i) { let o = 0, s = t.length; if (-1 === e) s = -1; else for (; o < t.length;) { const a = t[o++]; if ("number" == typeof a) { if (a === e) { s = -1; break } if (a > e) { s = o - 1; break } } } for (; o < t.length;) { const a = t[o]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== i && (t[o + 1] = i)); if (r === t[o + 1]) return void (t[o + 2] = i) } o++, null !== r && o++, null !== i && o++ } -1 !== s && (t.splice(s, 0, e), o = s + 1), t.splice(o++, 0, n), null !== r && t.splice(o++, 0, r), null !== i && t.splice(o++, 0, i) } function yh(t) { return -1 !== t } function xr(t) { return 32767 & t } function Nr(t, e) { let n = function Cw(t) { return t >> 16 }(t), r = e; for (; n > 0;)r = r[15], n--; return r } let jl = !0; function rs(t) { const e = jl; return jl = t, e } let Mw = 0; const tn = {}; function Ii(t, e) { const n = $l(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Hl(r.data, t), Hl(e, null), Hl(r.blueprint, null)); const i = is(t, e), o = t.injectorIndex; if (yh(i)) { const s = xr(i), a = Nr(i, e), l = a[1].data; for (let u = 0; u < 8; u++)e[o + u] = a[s + u] | l[s + u] } return e[o + 8] = i, o } function Hl(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function $l(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function is(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, i = e; for (; null !== i;) { if (r = Ah(i), null === r) return -1; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function os(t, e, n) { !function Aw(t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(bi) && (r = n[bi]), null == r && (r = n[bi] = Mw++); const i = 255 & r; e.data[t + (i >> 5)] |= 1 << i }(t, e, n) } function bh(t, e, n) { if (n & R.Optional) return t; jo() } function Dh(t, e, n, r) { if (n & R.Optional && void 0 === r && (r = null), 0 == (n & (R.Self | R.Host))) { const i = t[9], o = Xt(void 0); try { return i ? i.get(e, r, n & R.Optional) : Gf(e, r, n & R.Optional) } finally { Xt(o) } } return bh(r, 0, n) } function Eh(t, e, n, r = R.Default, i) { if (null !== t) { if (1024 & e[2]) { const s = function xw(t, e, n, r, i) { let o = t, s = e; for (; null !== o && null !== s && 1024 & s[2] && !(256 & s[2]);) { const a = wh(o, s, n, r | R.Self, tn); if (a !== tn) return a; let l = o.parent; if (!l) { const u = s[21]; if (u) { const c = u.get(n, tn, r); if (c !== tn) return c } l = Ah(s), s = s[15] } o = l } return i }(t, e, n, r, tn); if (s !== tn) return s } const o = wh(t, e, n, r, tn); if (o !== tn) return o } return Dh(e, n, r, i) } function wh(t, e, n, r, i) { const o = function Sw(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(bi) ? t[bi] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : Fw : e }(n); if ("function" == typeof o) { if (!uh(e, t, r)) return r & R.Host ? bh(i, 0, r) : Dh(e, n, r, i); try { const s = o(r); if (null != s || r & R.Optional) return s; jo() } finally { hh() } } else if ("number" == typeof o) { let s = null, a = $l(t, e), l = -1, u = r & R.Host ? e[16][6] : null; for ((-1 === a || r & R.SkipSelf) && (l = -1 === a ? is(t, e) : e[a + 8], -1 !== l && Mh(r, !1) ? (s = e[1], a = xr(l), e = Nr(l, e)) : a = -1); -1 !== a;) { const c = e[1]; if (Ch(o, a, c.data)) { const d = Iw(a, e, n, s, r, u); if (d !== tn) return d } l = e[a + 8], -1 !== l && Mh(r, e[1].data[a + 8] === u) && Ch(o, a, e) ? (s = c, a = xr(l), e = Nr(l, e)) : a = -1 } } return i } function Iw(t, e, n, r, i, o) { const s = e[1], a = s.data[t + 8], c = ss(a, s, n, null == r ? qo(a) && jl : r != s && 0 != (3 & a.type), i & R.Host && o === a); return null !== c ? Si(e, s, c, a) : tn } function ss(t, e, n, r, i) { const o = t.providerIndexes, s = e.data, a = 1048575 & o, l = t.directiveStart, c = o >> 20, f = i ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < l && n === p || h >= l && p.type === n) return h } if (i) { const h = s[l]; if (h && jt(h) && h.type === n) return l } return null } function Si(t, e, n, r) { let i = t[n]; const o = e.data; if (function bw(t) { return t instanceof Ai }(i)) { const s = i; s.resolving && function wE(t, e) { const n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : ""; throw new w(-200, `Circular dependency in DI detected for ${t}${n}`) }(function X(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : V(t) }(o[n])); const a = rs(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? Xt(s.injectImpl) : null; uh(t, r, R.Default); try { i = t[n] = s.factory(void 0, o, t, r), e.firstCreatePass && n >= r.directiveStart && function _w(t, e, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: o } = e.type.prototype; if (r) { const s = Yf(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, i), o && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, o), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, o)) }(n, o[n], e) } finally { null !== l && Xt(l), rs(a), s.resolving = !1, hh() } } return i } function Ch(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function Mh(t, e) { return !(t & R.Self || t & R.Host && e) } class kr { constructor(e, n) { this._tNode = e, this._lView = n } get(e, n, r) { return Eh(this._tNode, this._lView, e, r, n) } } function Fw() { return new kr(Te(), b()) } function Ul(t) { return fl(t) ? () => { const e = Ul(P(t)); return e && e() } : rr(t) } function Ah(t) { const e = t[1], n = e.type; return 2 === n ? e.declTNode : 1 === n ? t[6] : null } class I { constructor(e, n) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = G({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function ft(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let r = t[n]; Array.isArray(r) ? (e === t && (e = t.slice(0, n)), ft(r, e)) : e !== t && e.push(r) } return e } function wn(t, e) { t.forEach(n => Array.isArray(n) ? wn(n, e) : e(n)) } function Ih(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function as(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function Ni(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function ht(t, e, n) { let r = Vr(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function Pw(t, e, n, r) { let i = t.length; if (i == e) t.push(n, r); else if (1 === i) t.push(r, t[0]), t[0] = n; else { for (i--, t.push(t[i - 1], t[i]); i > e;)t[i] = t[i - 2], i--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function Wl(t, e) { const n = Vr(t, e); if (n >= 0) return t[1 | n] } function Vr(t, e) { return function xh(t, e, n) { let r = 0, i = t.length >> n; for (; i !== r;) { const o = r + (i - r >> 1), s = t[o << n]; if (e === s) return o << n; s > e ? i = o : r = o + 1 } return ~(i << n) }(t, e, 1) } const ki = {}, us = "ngTempTokenPath", Uw = /\n/gm, Nh = "__source"; let Oi; function cs(t) { const e = Oi; return Oi = t, e } function zw(t, e = R.Default) { if (void 0 === Oi) throw new w(-203, ""); return null === Oi ? Gf(t, void 0, e) : Oi.get(t, e & R.Optional ? null : void 0, e) } function S(t, e = R.Default) { return (function xE() { return ml }() || zw)(P(t), e) } function Zl(t, e = R.Default) { return S(t, e) } function Yl(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = P(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new w(900, ""); let i, o = R.Default; for (let s = 0; s < r.length; s++) { const a = r[s], l = qw(a); "number" == typeof l ? -1 === l ? i = a.token : o |= l : i = a } e.push(S(i, o)) } else e.push(S(r)) } return e } function qw(t) { return t.__NG_DI_FLAG__ } const ou = new Map; let FC = 0; const au = "__ngContext__"; function $e(t, e) { rt(e) ? (t[au] = e[20], function NC(t) { ou.set(t[20], t) }(e)) : t[au] = e } function Hi(t) { const e = t[au]; return "number" == typeof e ? function ep(t) { return ou.get(t) || null }(e) : e || null } function vs(t) { const e = Hi(t); return e ? rt(e) ? e : e.lView : null } function uu(t) { return t.ngOriginalError } function GC(t, ...e) { t.error(...e) } class Hr { constructor() { this._console = console } handleError(e) { const n = this._findOriginalError(e), r = function UC(t) { return t && t.ngErrorLogger || GC }(e); r(this._console, "ERROR", e), n && r(this._console, "ORIGINAL ERROR", n) } _findOriginalError(e) { let n = e && uu(e); for (; n && uu(n);)n = uu(n); return n || null } } const eM = (() => (typeof requestAnimationFrame < "u" && requestAnimationFrame || setTimeout).bind(ne))(); var pt = (() => ((pt = pt || {})[pt.Important = 1] = "Important", pt[pt.DashCase = 2] = "DashCase", pt))(); function du(t, e) { return undefined(t, e) } function $i(t) { const e = t[3]; return Bt(e) ? e[3] : e } function fu(t) { return cp(t[13]) } function hu(t) { return cp(t[4]) } function cp(t) { for (; null !== t && !Bt(t);)t = t[4]; return t } function Ur(t, e, n, r, i) { if (null != r) { let o, s = !1; Bt(r) ? o = r : rt(r) && (s = !0, r = r[0]); const a = we(r); 0 === t && null !== n ? null == i ? gp(e, n, a) : ir(e, n, a, i || null, !0) : 1 === t && null !== n ? ir(e, n, a, i || null, !0) : 2 === t ? function Cp(t, e, n) { const r = bs(t, e); r && function mM(t, e, n, r) { _e(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, s) : 3 === t && e.destroyNode(a), null != o && function _M(t, e, n, r, i) { const o = n[7]; o !== we(n) && Ur(e, t, r, o, i); for (let a = 10; a < n.length; a++) { const l = n[a]; Ui(l[1], l, t, e, r, o) } }(e, t, o, n, i) } } function mu(t, e, n) { if (_e(t)) return t.createElement(e, n); { const r = null !== n ? function QE(t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(n) : null; return null === r ? t.createElement(e) : t.createElementNS(r, e) } } function fp(t, e) { const n = t[9], r = n.indexOf(e), i = e[3]; 512 & e[2] && (e[2] &= -513, Sl(i, -1)), n.splice(r, 1) } function gu(t, e) { if (t.length <= 10) return; const n = 10 + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && fp(i, r), e > 0 && (t[n - 1][4] = r[4]); const o = as(t, 10 + e); !function aM(t, e) { Ui(t, e, e[$], 2, null, null), e[0] = null, e[6] = null }(r[1], r); const s = o[19]; null !== s && s.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -65 } return r } function hp(t, e) { if (!(128 & e[2])) { const n = e[$]; _e(n) && n.destroyNode && Ui(t, e, n, 3, null, null), function cM(t) { let e = t[13]; if (!e) return yu(t[1], t); for (; e;) { let n = null; if (rt(e)) n = e[13]; else { const r = e[10]; r && (n = r) } if (!n) { for (; e && !e[4] && e !== t;)rt(e) && yu(e[1], e), e = e[3]; null === e && (e = t), rt(e) && yu(e[1], e), n = e && e[4] } e = n } }(e) } } function yu(t, e) { if (!(128 & e[2])) { e[2] &= -65, e[2] |= 128, function pM(t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const i = e[n[r]]; if (!(i instanceof Ai)) { const o = n[r + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = i[o[s]], l = o[s + 1]; try { l.call(a) } finally { } } else try { o.call(i) } finally { } } } }(t, e), function hM(t, e) { const n = t.cleanup, r = e[7]; let i = -1; if (null !== n) for (let o = 0; o < n.length - 1; o += 2)if ("string" == typeof n[o]) { const s = n[o + 1], a = "function" == typeof s ? s(e) : we(e[s]), l = r[i = n[o + 2]], u = n[o + 3]; "boolean" == typeof u ? a.removeEventListener(n[o], l, u) : u >= 0 ? r[i = u]() : r[i = -u].unsubscribe(), o += 2 } else { const s = r[i = n[o + 1]]; n[o].call(s) } if (null !== r) { for (let o = i + 1; o < r.length; o++)r[o](); e[7] = null } }(t, e), 1 === e[1].type && _e(e[$]) && e[$].destroy(); const n = e[17]; if (null !== n && Bt(e[3])) { n !== e[3] && fp(n, e); const r = e[19]; null !== r && r.detachView(t) } !function kC(t) { ou.delete(t[20]) }(e) } } function pp(t, e, n) { return function mp(t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const i = t.data[r.directiveStart].encapsulation; if (i === Lt.None || i === Lt.Emulated) return null } return Ct(r, n) }(t, e.parent, n) } function ir(t, e, n, r, i) { _e(t) ? t.insertBefore(e, n, r, i) : (_p(e) ? e.content : e).insertBefore(n, r, i) } function gp(t, e, n) { _e(t) ? t.appendChild(e, n) : (_p(e) ? e.content : e).appendChild(n) } function yp(t, e, n, r, i) { null !== r ? ir(t, e, n, r, i) : gp(t, e, n) } function _p(t) { return "TEMPLATE" === t.tagName && void 0 !== t.content } function bs(t, e) { return _e(t) ? t.parentNode(e) : e.parentNode } function vp(t, e, n) { return Dp(t, e, n) } let Dp = function bp(t, e, n) { return 40 & t.type ? Ct(t, n) : null }; function Ds(t, e, n, r) { const i = pp(t, r, e), o = e[$], a = vp(r.parent || e[6], r, e); if (null != i) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)yp(o, i, n[l], a, !1); else yp(o, i, n, a, !1) } function Es(t, e) { if (null !== e) { const n = e.type; if (3 & n) return Ct(e, t); if (4 & n) return vu(-1, t[e.index]); if (8 & n) { const r = e.child; if (null !== r) return Es(t, r); { const i = t[e.index]; return Bt(i) ? vu(-1, i) : we(i) } } if (32 & n) return du(e, t)() || we(t[e.index]); { const r = wp(t, e); return null !== r ? Array.isArray(r) ? r[0] : Es($i(t[16]), r) : Es(t, e.next) } } return null } function wp(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function vu(t, e) { const n = 10 + t + 1; if (n < e.length) { const r = e[n], i = r[1].firstChild; if (null !== i) return Es(r, i) } return e[7] } function bu(t, e, n, r, i, o, s) { for (; null != n;) { const a = r[n.index], l = n.type; if (s && 0 === e && (a && $e(we(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) bu(t, e, n.child, r, i, o, !1), Ur(e, t, i, a, o); else if (32 & l) { const u = du(n, r); let c; for (; c = u();)Ur(e, t, i, c, o); Ur(e, t, i, a, o) } else 16 & l ? Mp(t, e, r, n, i, o) : Ur(e, t, i, a, o); n = s ? n.projectionNext : n.next } } function Ui(t, e, n, r, i, o) { bu(n, r, t.firstChild, e, i, o, !1) } function Mp(t, e, n, r, i, o) { const s = n[16], l = s[6].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++)Ur(e, t, i, l[u], o); else bu(t, e, l, s[3], i, o, !0) } function Ap(t, e, n) { _e(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Du(t, e, n) { _e(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function Tp(t, e, n) { let r = t.length; for (; ;) { const i = t.indexOf(e, n); if (-1 === i) return i; if (0 === i || t.charCodeAt(i - 1) <= 32) { const o = e.length; if (i + o === r || t.charCodeAt(i + o) <= 32) return i } n = i + 1 } } const Ip = "ng-template"; function bM(t, e, n) { let r = 0; for (; r < t.length;) { let i = t[r++]; if (n && "class" === i) { if (i = t[r], -1 !== Tp(i.toLowerCase(), e, 0)) return !0 } else if (1 === i) { for (; r < t.length && "string" == typeof (i = t[r++]);)if (i.toLowerCase() === e) return !0; return !1 } } return !1 } function Sp(t) { return 4 === t.type && t.value !== Ip } function DM(t, e, n) { return e === (4 !== t.type || n ? t.value : Ip) } function EM(t, e, n) { let r = 4; const i = t.attrs || [], o = function MM(t) { for (let e = 0; e < t.length; e++)if (mh(t[e])) return e; return t.length }(i); let s = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !DM(t, l, n) || "" === l && 1 === e.length) { if (Ht(r)) return !1; s = !0 } } else { const u = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!bM(t.attrs, u, n)) { if (Ht(r)) return !1; s = !0 } continue } const d = wM(8 & r ? "class" : l, i, Sp(t), n); if (-1 === d) { if (Ht(r)) return !1; s = !0; continue } if ("" !== u) { let f; f = d > o ? "" : i[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Tp(h, u, 0) || 2 & r && u !== f) { if (Ht(r)) return !1; s = !0 } } } } else { if (!s && !Ht(r) && !Ht(l)) return !1; if (s && Ht(l)) continue; s = !1, r = l | 1 & r } } return Ht(r) || s } function Ht(t) { return 0 == (1 & t) } function wM(t, e, n, r) { if (null === e) return -1; let i = 0; if (r || !n) { let o = !1; for (; i < e.length;) { const s = e[i]; if (s === t) return i; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = e[++i]; for (; "string" == typeof a;)a = e[++i]; continue } if (4 === s) break; if (0 === s) { i += 4; continue } } i += o ? 1 : 2 } return -1 } return function AM(t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function Fp(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (EM(t, e[r], n)) return !0; return !1 } function TM(t, e) { e: for (let n = 0; n < e.length; n++) { const r = e[n]; if (t.length === r.length) { for (let i = 0; i < t.length; i++)if (t[i] !== r[i]) continue e; return !0 } } return !1 } function xp(t, e) { return t ? ":not(" + e.trim() + ")" : e } function IM(t) { let e = t[0], n = 1, r = 2, i = "", o = !1; for (; n < t.length;) { let s = t[n]; if ("string" == typeof s) if (2 & r) { const a = t[++n]; i += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? i += "." + s : 4 & r && (i += " " + s); else "" !== i && !Ht(s) && (e += xp(o, i), i = ""), r = s, o = o || !Ht(r); n++ } return "" !== i && (e += xp(o, i)), e } const B = {}; function Le(t) { Np(K(), b(), Ye() + t, !1) } function Np(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const o = t.preOrderCheckHooks; null !== o && Jo(e, o, n) } else { const o = t.preOrderHooks; null !== o && es(e, o, 0, n) } Pn(n) } const Rp = new I("ENVIRONMENT_INITIALIZER"), Lp = new I("INJECTOR_DEF_TYPES"); function RM(...t) { return { \u0275providers: Vp(0, t) } } function Vp(t, ...e) { const n = [], r = new Set; let i; return wn(e, o => { const s = o; Eu(s, n, [], r) && (i || (i = []), i.push(s)) }), void 0 !== i && Bp(i, n), n } function Bp(t, e) { for (let n = 0; n < t.length; n++) { const { providers: i } = t[n]; wn(i, o => { e.push(o) }) } } function Eu(t, e, n, r) { if (!(t = P(t))) return !1; let i = null, o = $f(t); const s = !o && oe(t); if (o || s) { if (s && !s.standalone) return !1; i = t } else { const l = t.ngModule; if (o = $f(l), !o) return !1; i = l } const a = r.has(i); if (s) { if (a) return !1; if (r.add(i), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const u of l) Eu(u, e, n, r) } } else { if (!o) return !1; { if (null != o.imports && !a) { let u; r.add(i); try { wn(o.imports, c => { Eu(c, e, n, r) && (u || (u = []), u.push(c)) }) } finally { } void 0 !== u && Bp(u, e) } if (!a) { const u = rr(i) || (() => new i); e.push({ provide: i, useFactory: u, deps: J }, { provide: Lp, useValue: i, multi: !0 }, { provide: Rp, useValue: () => S(i), multi: !0 }) } const l = o.providers; null == l || a || wn(l, c => { e.push(c) }) } } return i !== t && void 0 !== t.providers } const LM = re({ provide: String, useValue: re }); function wu(t) { return null !== t && "object" == typeof t && LM in t } function or(t) { return "function" == typeof t } const Cu = new I("INJECTOR", -1); class $p { get(e, n = ki) { if (n === ki) { const r = new Error(`NullInjectorError: No provider for ${ie(e)}!`); throw r.name = "NullInjectorError", r } return n } } const Mu = new I("Set Injector scope."), ws = {}, BM = {}; let Au; function Tu() { return void 0 === Au && (Au = new $p), Au } class Gi { } class Up extends Gi { constructor(e, n, r, i) { super(), this.parent = n, this.source = r, this.scopes = i, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Su(e, s => this.processProvider(s)), this.records.set(Cu, Gr(void 0, this)), i.has("environment") && this.records.set(Gi, Gr(void 0, this)); const o = this.records.get(Mu); null != o && "string" == typeof o.value && this.scopes.add(o.value), this.injectorDefTypes = new Set(this.get(Lp.multi, J, R.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const e of this._ngOnDestroyHooks) e.ngOnDestroy(); for (const e of this._onDestroyHooks) e() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(e) { this._onDestroyHooks.push(e) } get(e, n = ki, r = R.Default) { this.assertNotDestroyed(); const i = cs(this), o = Xt(void 0); try { if (!(r & R.SkipSelf)) { let a = this.records.get(e); if (void 0 === a) { const l = function GM(t) { return "function" == typeof t || "object" == typeof t && t instanceof I }(e) && hl(e); a = l && this.injectableDefInScope(l) ? Gr(Iu(e), ws) : null, this.records.set(e, a) } if (null != a) return this.hydrate(e, a) } return (r & R.Self ? Tu() : this.parent).get(e, n = r & R.Optional && n === ki ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[us] = s[us] || []).unshift(ie(e)), i) throw s; return function Ww(t, e, n, r) { const i = t[us]; throw e[Nh] && i.unshift(e[Nh]), t.message = function Kw(t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.slice(2) : t; let i = ie(e); if (Array.isArray(e)) i = e.map(ie).join(" -> "); else if ("object" == typeof e) { let o = []; for (let s in e) if (e.hasOwnProperty(s)) { let a = e[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : ie(a))) } i = `{${o.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(Uw, "\n  ")}` }("\n" + t.message, i, n, r), t.ngTokenPath = i, t[us] = null, t }(s, e, "R3InjectorError", this.source) } throw s } finally { Xt(o), cs(i) } } resolveInjectorInitializers() { const e = cs(this), n = Xt(void 0); try { const r = this.get(Rp.multi, J, R.Self); for (const i of r) i() } finally { cs(e), Xt(n) } } toString() { const e = [], n = this.records; for (const r of n.keys()) e.push(ie(r)); return `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new w(205, !1) } processProvider(e) { let n = or(e = P(e)) ? e : P(e && e.provide); const r = function HM(t) { return wu(t) ? Gr(void 0, t.useValue) : Gr(Gp(t), ws) }(e); if (or(e) || !0 !== e.multi) this.records.get(n); else { let i = this.records.get(n); i || (i = Gr(void 0, ws, !0), i.factory = () => Yl(i.multi), this.records.set(n, i)), n = e, i.multi.push(e) } this.records.set(n, r) } hydrate(e, n) { return n.value === ws && (n.value = BM, n.value = n.factory()), "object" == typeof n.value && n.value && function UM(t) { return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(e) { if (!e.providedIn) return !1; const n = P(e.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function Iu(t) { const e = hl(t), n = null !== e ? e.factory : rr(t); if (null !== n) return n; if (t instanceof I) throw new w(204, !1); if (t instanceof Function) return function jM(t) { const e = t.length; if (e > 0) throw Ni(e, "?"), new w(204, !1); const n = function IE(t) { const e = t && (t[Ho] || t[Uf]); if (e) { const n = function SE(t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new w(204, !1) } function Gp(t, e, n) { let r; if (or(t)) { const i = P(t); return rr(i) || Iu(i) } if (wu(t)) r = () => P(t.useValue); else if (function Hp(t) { return !(!t || !t.useFactory) }(t)) r = () => t.useFactory(...Yl(t.deps || [])); else if (function jp(t) { return !(!t || !t.useExisting) }(t)) r = () => S(P(t.useExisting)); else { const i = P(t && (t.useClass || t.provide)); if (!function $M(t) { return !!t.deps }(t)) return rr(i) || Iu(i); r = () => new i(...Yl(t.deps)) } return r } function Gr(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function zM(t) { return !!t.\u0275providers } function Su(t, e) { for (const n of t) Array.isArray(n) ? Su(n, e) : zM(n) ? Su(n.\u0275providers, e) : e(n) } function zp(t, e = null, n = null, r) { const i = qp(t, e, n, r); return i.resolveInjectorInitializers(), i } function qp(t, e = null, n = null, r, i = new Set) { const o = [n || J, RM(t)]; return r = r || ("object" == typeof t ? void 0 : ie(t)), new Up(o, e || Tu(), r || null, i) } let $t = (() => { class t { static create(n, r) { if (Array.isArray(n)) return zp({ name: "" }, r, n, ""); { const i = n.name ?? ""; return zp({ name: i }, n.parent, n.providers, i) } } } return t.THROW_IF_NOT_FOUND = ki, t.NULL = new $p, t.\u0275prov = G({ token: t, providedIn: "any", factory: () => S(Cu) }), t.__NG_ELEMENT_ID__ = -1, t })(); function v(t, e = R.Default) { const n = b(); return null === n ? S(t, e) : Eh(Te(), n, P(t), e) } function Ms(t, e) { return t << 17 | e << 2 } function Ut(t) { return t >> 17 & 32767 } function Ou(t) { return 2 | t } function Mn(t) { return (131068 & t) >> 2 } function Pu(t, e) { return -131069 & t | e << 2 } function Ru(t) { return 1 | t } function um(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], o = n[r + 1]; if (-1 !== o) { const s = t.data[o]; Rl(i), s.contentQueries(2, e[o], o) } } } function zi(t, e, n, r, i, o, s, a, l, u, c) { const d = e.blueprint.slice(); return d[0] = i, d[2] = 76 | r, (null !== c || t && 1024 & t[2]) && (d[2] |= 1024), nh(d), d[3] = d[15] = t, d[8] = n, d[10] = s || t && t[10], d[$] = a || t && t[$], d[12] = l || t && t[12] || null, d[9] = u || t && t[9] || null, d[6] = o, d[20] = function xC() { return FC++ }(), d[21] = c, d[16] = 2 == e.type ? t[16] : d, d } function qr(t, e, n, r, i) { let o = t.data[e]; if (null === o) o = function qu(t, e, n, r, i) { const o = oh(), s = Nl(), l = t.data[e] = function E0(t, e, n, r, i, o) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, n, e, r, i); return null === t.firstChild && (t.firstChild = l), null !== o && (s ? null == o.child && null !== l.parent && (o.child = l) : null === o.next && (o.next = l)), l }(t, e, n, r, i), function aw() { return L.lFrame.inI18n }() && (o.flags |= 64); else if (64 & o.type) { o.type = n, o.value = r, o.attrs = i; const s = function Mi() { const t = L.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return en(o, !0), o } function Wr(t, e, n, r) { if (0 === n) return -1; const i = e.length; for (let o = 0; o < n; o++)e.push(r), t.blueprint.push(r), t.data.push(null); return i } function qi(t, e, n) { Zo(e); try { const r = t.viewQuery; null !== r && tc(1, r, n); const i = t.template; null !== i && hm(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && um(t, e), t.staticViewQueries && tc(2, t.viewQuery, n); const o = t.components; null !== o && function v0(t, e) { for (let n = 0; n < e.length; n++)H0(t, e[n]) }(e, o) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r } finally { e[2] &= -5, Yo() } } function Kr(t, e, n, r) { const i = e[2]; if (128 != (128 & i)) { Zo(e); try { nh(e), function sh(t) { return L.lFrame.bindingIndex = t }(t.bindingStartIndex), null !== n && hm(t, e, n, 2, r); const s = 3 == (3 & i); if (s) { const u = t.preOrderCheckHooks; null !== u && Jo(e, u, null) } else { const u = t.preOrderHooks; null !== u && es(e, u, 0, null), Ll(e, 0) } if (function B0(t) { for (let e = fu(t); null !== e; e = hu(e)) { if (!e[2]) continue; const n = e[9]; for (let r = 0; r < n.length; r++) { const i = n[r], o = i[3]; 0 == (512 & i[2]) && Sl(o, 1), i[2] |= 512 } } }(e), function V0(t) { for (let e = fu(t); null !== e; e = hu(e))for (let n = 10; n < e.length; n++) { const r = e[n], i = r[1]; Il(r) && Kr(i, r, i.template, r[8]) } }(e), null !== t.contentQueries && um(t, e), s) { const u = t.contentCheckHooks; null !== u && Jo(e, u) } else { const u = t.contentHooks; null !== u && es(e, u, 1), Ll(e, 1) } !function y0(t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const i = n[r]; if (i < 0) Pn(~i); else { const o = i, s = n[++r], a = n[++r]; lw(s, o), a(2, e[o]) } } } finally { Pn(-1) } }(t, e); const a = t.components; null !== a && function _0(t, e) { for (let n = 0; n < e.length; n++)j0(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && tc(2, l, r), s) { const u = t.viewCheckHooks; null !== u && Jo(e, u) } else { const u = t.viewHooks; null !== u && es(e, u, 2), Ll(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), e[2] &= -41, 512 & e[2] && (e[2] &= -513, Sl(e[3], -1)) } finally { Yo() } } } function b0(t, e, n, r) { const i = e[10], s = th(e); try { !s && i.begin && i.begin(), s && qi(t, e, r), Kr(t, e, n, r) } finally { !s && i.end && i.end() } } function hm(t, e, n, r, i) { const o = Ye(), s = 2 & r; try { Pn(-1), s && e.length > 22 && Np(t, e, 22, !1), n(r, i) } finally { Pn(o) } } function pm(t, e, n) { if (bl(e)) { const i = e.directiveEnd; for (let o = e.directiveStart; o < i; o++) { const s = t.data[o]; s.contentQueries && s.contentQueries(1, n[o], o) } } } function Wu(t, e, n) { !ih() || (function F0(t, e, n, r) { const i = n.directiveStart, o = n.directiveEnd; t.firstCreatePass || Ii(n, e), $e(r, e); const s = n.initialInputs; for (let a = i; a < o; a++) { const l = t.data[a], u = jt(l); u && P0(e, n, l); const c = Si(e, t, a, n); $e(c, e), null !== s && R0(0, a - i, c, l, 0, s), u && (dt(n.index, e)[8] = c) } }(t, e, n, Ct(n, e)), 128 == (128 & n.flags) && function x0(t, e, n) { const r = n.directiveStart, i = n.directiveEnd, o = n.index, s = function uw() { return L.lFrame.currentDirectiveIndex }(); try { Pn(o); for (let a = r; a < i; a++) { const l = t.data[a], u = e[a]; Ol(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && Em(l, u) } } finally { Pn(-1), Ol(s) } }(t, e, n)) } function Ku(t, e, n = Ct) { const r = e.localNames; if (null !== r) { let i = e.index + 1; for (let o = 0; o < r.length; o += 2) { const s = r[o + 1], a = -1 === s ? n(e, t) : t[s]; t[i++] = a } } } function mm(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Is(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Is(t, e, n, r, i, o, s, a, l, u) { const c = 22 + r, d = c + i, f = function D0(t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : B); return n }(c, d), h = "function" == typeof u ? u() : u; return f[1] = { type: t, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: e, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: h, incompleteFirstPass: !1 } } function _m(t, e, n, r) { const i = Im(e); null === n ? i.push(r) : (i.push(n), t.firstCreatePass && Sm(t).push(r, i.length - 1)) } function vm(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const i = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, i) : n[r] = [e, i] } return n } function mt(t, e, n, r, i, o, s, a) { const l = Ct(e, n); let c, u = e.inputs; !a && null != u && (c = u[r]) ? (Nm(t, n, c, r, i), qo(e) && function M0(t, e) { const n = dt(e, t); 16 & n[2] || (n[2] |= 32) }(n, e.index)) : 3 & e.type && (r = function C0(t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(r), i = null != s ? s(i, e.value || "", r) : i, _e(o) ? o.setProperty(l, r, i) : Bl(r) || (l.setProperty ? l.setProperty(r, i) : l[r] = i)) } function Qu(t, e, n, r) { let i = !1; if (ih()) { const o = function N0(t, e, n) { const r = t.directiveRegistry; let i = null; if (r) for (let o = 0; o < r.length; o++) { const s = r[o]; Fp(n, s.selectors, !1) && (i || (i = []), os(Ii(n, e), t, s.type), jt(s) ? (wm(t, n), i.unshift(s)) : i.push(s)) } return i }(t, e, n), s = null === r ? null : { "": -1 }; if (null !== o) { i = !0, Cm(n, t.data.length, o.length); for (let c = 0; c < o.length; c++) { const d = o[c]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, u = Wr(t, e, o.length, null); for (let c = 0; c < o.length; c++) { const d = o[c]; n.mergedAttrs = ns(n.mergedAttrs, d.hostAttrs), Mm(t, n, e, u, d), O0(u, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), a = !0), !l && (f.ngOnChanges || f.ngDoCheck) && ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), l = !0), u++ } !function w0(t, e) { const r = e.directiveEnd, i = t.data, o = e.attrs, s = []; let a = null, l = null; for (let u = e.directiveStart; u < r; u++) { const c = i[u], d = c.inputs, f = null === o || Sp(e) ? null : L0(d, o); s.push(f), a = vm(d, u, a), l = vm(c.outputs, u, l) } null !== a && (a.hasOwnProperty("class") && (e.flags |= 16), a.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = s, e.inputs = a, e.outputs = l }(t, n) } s && function k0(t, e, n) { if (e) { const r = t.localNames = []; for (let i = 0; i < e.length; i += 2) { const o = n[e[i + 1]]; if (null == o) throw new w(-301, !1); r.push(e[i], o) } } }(n, r, s) } return n.mergedAttrs = ns(n.mergedAttrs, n.attrs), i } function Dm(t, e, n, r, i, o) { const s = o.hostBindings; if (s) { let a = t.hostBindingOpCodes; null === a && (a = t.hostBindingOpCodes = []); const l = ~e.index; (function S0(t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != l && a.push(l), a.push(r, i, s) } } function Em(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function wm(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function O0(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; jt(e) && (n[""] = t) } } function Cm(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function Mm(t, e, n, r, i) { t.data[r] = i; const o = i.factory || (i.factory = rr(i.type)), s = new Ai(o, jt(i), v); t.blueprint[r] = s, n[r] = s, Dm(t, e, 0, r, Wr(t, n, i.hostVars, B), i) } function P0(t, e, n) { const r = Ct(e, t), i = mm(n), o = t[10], s = Ss(t, zi(t, i, null, n.onPush ? 32 : 16, r, e, o, o.createRenderer(r, n), null, null, null)); t[e.index] = s } function rn(t, e, n, r, i, o) { const s = Ct(t, e); !function Zu(t, e, n, r, i, o, s) { if (null == o) _e(t) ? t.removeAttribute(e, i, n) : e.removeAttribute(i); else { const a = null == s ? V(o) : s(o, r || "", i); _e(t) ? t.setAttribute(e, i, a, n) : n ? e.setAttributeNS(n, i, a) : e.setAttribute(i, a) } }(e[$], s, o, t.value, n, r, i) } function R0(t, e, n, r, i, o) { const s = o[e]; if (null !== s) { const a = r.setInput; for (let l = 0; l < s.length;) { const u = s[l++], c = s[l++], d = s[l++]; null !== a ? r.setInput(n, d, u, c) : n[c] = d } } } function L0(t, e) { let n = null, r = 0; for (; r < e.length;) { const i = e[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; t.hasOwnProperty(i) && (null === n && (n = []), n.push(i, t[i], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Am(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function j0(t, e) { const n = dt(e, t); if (Il(n)) { const r = n[1]; 48 & n[2] ? Kr(r, n, r.template, n[8]) : n[5] > 0 && Yu(n) } } function Yu(t) { for (let r = fu(t); null !== r; r = hu(r))for (let i = 10; i < r.length; i++) { const o = r[i]; if (512 & o[2]) { const s = o[1]; Kr(s, o, s.template, o[8]) } else o[5] > 0 && Yu(o) } const n = t[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const i = dt(n[r], t); Il(i) && i[5] > 0 && Yu(i) } } function H0(t, e) { const n = dt(e, t), r = n[1]; (function $0(t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) })(r, n), qi(r, n, n[8]) } function Ss(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Xu(t) { for (; t;) { t[2] |= 32; const e = $i(t); if (BE(t) && !e) return t; t = e } return null } function Tm(t) { !function Ju(t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = vs(n); if (null !== r) { const i = r[1]; b0(i, r, i.template, n) } } }(t[8]) } function tc(t, e, n) { Rl(0), e(t, n) } const G0 = (() => Promise.resolve(null))(); function Im(t) { return t[7] || (t[7] = []) } function Sm(t) { return t.cleanup || (t.cleanup = []) } function xm(t, e) { const n = t[9], r = n ? n.get(Hr, null) : null; r && r.handleError(e) } function Nm(t, e, n, r, i) { for (let o = 0; o < n.length;) { const s = n[o++], a = n[o++], l = e[s], u = t.data[s]; null !== u.setInput ? u.setInput(l, i, r, a) : l[a] = i } } function An(t, e, n) { const r = Ko(e, t); !function dp(t, e, n) { _e(t) ? t.setValue(e, n) : e.textContent = n }(t[$], r, n) } function Fs(t, e, n) { let r = n ? t.styles : null, i = n ? t.classes : null, o = 0; if (null !== e) for (let s = 0; s < e.length; s++) { const a = e[s]; "number" == typeof a ? o = a : 1 == o ? i = dl(i, a) : 2 == o && (r = dl(r, a + ": " + e[++s] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i } function tA(t, e) { Xo(vs(t)[1], Te()) } function Y(t) { let e = function Gm(t) { return Object.getPrototypeOf(t.prototype).constructor }(t.type), n = !0; const r = [t]; for (; e;) { let i; if (jt(t)) i = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new w(903, ""); i = e.\u0275dir } if (i) { if (n) { r.push(i); const s = t; s.inputs = rc(t.inputs), s.declaredInputs = rc(t.declaredInputs), s.outputs = rc(t.outputs); const a = i.hostBindings; a && oA(t, a); const l = i.viewQuery, u = i.contentQueries; if (l && rA(t, l), u && iA(t, u), cl(t.inputs, i.inputs), cl(t.declaredInputs, i.declaredInputs), cl(t.outputs, i.outputs), jt(i) && i.data.animation) { const c = t.data; c.animation = (c.animation || []).concat(i.data.animation) } } const o = i.features; if (o) for (let s = 0; s < o.length; s++) { const a = o[s]; a && a.ngInherit && a(t), a === Y && (n = !1) } } e = Object.getPrototypeOf(e) } !function nA(t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; i.hostVars = e += i.hostVars, i.hostAttrs = ns(i.hostAttrs, n = ns(n, i.hostAttrs)) } }(r) } function rc(t) { return t === Cr ? {} : t === J ? [] : t } function rA(t, e) { const n = t.viewQuery; t.viewQuery = n ? (r, i) => { e(r, i), n(r, i) } : e } function iA(t, e) { const n = t.contentQueries; t.contentQueries = n ? (r, i, o) => { e(r, i, o), n(r, i, o) } : e } function oA(t, e) { const n = t.hostBindings; t.hostBindings = n ? (r, i) => { e(r, i), n(r, i) } : e } let xs = null; function sr() { if (!xs) { const t = ne.Symbol; if (t && t.iterator) xs = t.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < e.length; ++n) { const r = e[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (xs = r) } } } return xs } function Ue(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function At(t, e, n, r) { const i = b(); return Ue(i, Fr(), e) && (K(), rn(ve(), i, t, e, n, r)), At } function Tt(t, e, n, r, i, o, s, a) { const l = b(), u = K(), c = t + 22, d = u.firstCreatePass ? function fA(t, e, n, r, i, o, s, a, l) { const u = e.consts, c = qr(e, t, 4, s || null, On(u, a)); Qu(e, n, c, On(u, l)), Xo(e, c); const d = c.tViews = Is(2, c, r, i, o, e.directiveRegistry, e.pipeRegistry, null, e.schemas, u); return null !== e.queries && (e.queries.template(e, c), d.queries = e.queries.embeddedTView(c)), c }(c, u, l, e, n, r, i, o, s) : u.data[c]; en(d, !1); const f = l[$].createComment(""); Ds(u, l, f, d), $e(f, l), Ss(l, l[c] = Am(f, l, f, d)), Wo(d) && Wu(u, l, d), null != s && Ku(l, d, a) } function De(t, e, n) { const r = b(); return Ue(r, Fr(), e) && mt(K(), ve(), r, t, e, r[$], n, !1), De } function oc(t, e, n, r, i) { const s = i ? "class" : "style"; Nm(t, n, e.inputs[s], s, r) } function he(t, e, n, r) { const i = b(), o = K(), s = 22 + t, a = i[$], l = i[s] = mu(a, e, function yw() { return L.lFrame.currentNamespace }()), u = o.firstCreatePass ? function mA(t, e, n, r, i, o, s) { const a = e.consts, u = qr(e, t, 2, i, On(a, o)); return Qu(e, n, u, On(a, s)), null !== u.attrs && Fs(u, u.attrs, !1), null !== u.mergedAttrs && Fs(u, u.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, u), u }(s, o, i, 0, e, n, r) : o.data[s]; en(u, !0); const c = u.mergedAttrs; null !== c && ts(a, l, c); const d = u.classes; null !== d && Du(a, l, d); const f = u.styles; return null !== f && Ap(a, l, f), 64 != (64 & u.flags) && Ds(o, i, l, u), 0 === function tw() { return L.lFrame.elementDepthCount }() && $e(l, i), function nw() { L.lFrame.elementDepthCount++ }(), Wo(u) && (Wu(o, i, u), pm(o, u, i)), null !== r && Ku(i, u), he } function de() { let t = Te(); Nl() ? kl() : (t = t.parent, en(t, !1)); const e = t; !function rw() { L.lFrame.elementDepthCount-- }(); const n = K(); return n.firstCreatePass && (Xo(n, t), bl(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function Ew(t) { return 0 != (16 & t.flags) }(e) && oc(n, e, b(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function ww(t) { return 0 != (32 & t.flags) }(e) && oc(n, e, b(), e.stylesWithoutHost, !1), de } function sn(t, e, n, r) { return he(t, e, n, r), de(), sn } function Qi(t, e, n) { const r = b(), i = K(), o = t + 22, s = i.firstCreatePass ? function gA(t, e, n, r, i) { const o = e.consts, s = On(o, r), a = qr(e, t, 8, "ng-container", s); return null !== s && Fs(a, s, !0), Qu(e, n, a, On(o, i)), null !== e.queries && e.queries.elementStart(e, a), a }(o, i, r, e, n) : i.data[o]; en(s, !0); const a = r[o] = r[$].createComment(""); return Ds(i, r, a, s), $e(a, r), Wo(s) && (Wu(i, r, s), pm(i, s, r)), null != n && Ku(r, s), Qi } function Zi() { let t = Te(); const e = K(); return Nl() ? kl() : (t = t.parent, en(t, !1)), e.firstCreatePass && (Xo(e, t), bl(t) && e.queries.elementEnd(t)), Zi } function ac() { return b() } function ks(t) { return !!t && "function" == typeof t.then } const ng = function tg(t) { return !!t && "function" == typeof t.subscribe }; function Ge(t, e, n, r) { const i = b(), o = K(), s = Te(); return function ig(t, e, n, r, i, o, s, a) { const l = Wo(r), c = t.firstCreatePass && Sm(t), d = e[8], f = Im(e); let h = !0; if (3 & r.type || a) { const y = Ct(r, e), _ = a ? a(y) : y, D = f.length, g = a ? E => a(we(E[r.index])) : r.index; if (_e(n)) { let E = null; if (!a && l && (E = function yA(t, e, n, r) { const i = t.cleanup; if (null != i) for (let o = 0; o < i.length - 1; o += 2) { const s = i[o]; if (s === n && i[o + 1] === r) { const a = e[7], l = i[o + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (o += 2) } return null }(t, e, i, r.index)), null !== E) (E.__ngLastListenerFn__ || E).__ngNextListenerFn__ = o, E.__ngLastListenerFn__ = o, h = !1; else { o = lc(r, e, d, o, !1); const j = n.listen(_, i, o); f.push(o, j), c && c.push(i, g, D, D + 1) } } else o = lc(r, e, d, o, !0), _.addEventListener(i, o, s), f.push(o), c && c.push(i, g, D, s) } else o = lc(r, e, d, o, !1); const p = r.outputs; let m; if (h && null !== p && (m = p[i])) { const y = m.length; if (y) for (let _ = 0; _ < y; _ += 2) { const W = e[m[_]][m[_ + 1]].subscribe(o), me = f.length; f.push(o, W), c && c.push(i, r.index, me, -(me + 1)) } } }(o, i, i[$], s, t, e, !!n, r), Ge } function og(t, e, n, r) { try { return !1 !== n(r) } catch (i) { return xm(t, i), !1 } } function lc(t, e, n, r, i) { return function o(s) { if (s === Function) return r; Xu(2 & t.flags ? dt(t.index, e) : e); let l = og(e, 0, r, s), u = o.__ngNextListenerFn__; for (; u;)l = og(e, 0, u, s) && l, u = u.__ngNextListenerFn__; return i && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function an(t = 1) { return function dw(t) { return (L.lFrame.contextLView = function fw(t, e) { for (; t > 0;)e = e[15], t--; return e }(t, L.lFrame.contextLView))[8] }(t) } function _A(t, e) { let n = null; const r = function CM(t) { const e = t.attrs; if (null != e) { const n = e.indexOf(5); if (0 == (1 & n)) return e[n + 1] } return null }(t); for (let i = 0; i < e.length; i++) { const o = e[i]; if ("*" !== o) { if (null === r ? Fp(t, o, !0) : TM(r, o)) return i } else n = i } return n } function uc(t) { const e = b()[16][6]; if (!e.projection) { const r = e.projection = Ni(t ? t.length : 1, null), i = r.slice(); let o = e.child; for (; null !== o;) { const s = t ? _A(o, t) : 0; null !== s && (i[s] ? i[s].projectionNext = o : r[s] = o, i[s] = o), o = o.next } } } function ln(t, e = 0, n) { const r = b(), i = K(), o = qr(i, 22 + t, 16, null, n || null); null === o.projection && (o.projection = e), kl(), 64 != (64 & o.flags) && function yM(t, e, n) { Mp(e[$], 0, e, n, pp(t, n, e), vp(n.parent || e[6], n, e)) }(i, r, o) } function mg(t, e, n, r, i) { const o = t[n + 1], s = null === e; let a = r ? Ut(o) : Mn(o), l = !1; for (; 0 !== a && (!1 === l || s);) { const c = t[a + 1]; DA(t[a], e) && (l = !0, t[a + 1] = r ? Ru(c) : Ou(c)), a = r ? Ut(c) : Mn(c) } l && (t[n + 1] = r ? Ou(o) : Ru(o)) } function DA(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && Vr(t, e) >= 0 } function zt(t, e) { return function qt(t, e, n, r) { const i = b(), o = K(), s = function En(t) { const e = L.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n }(2); o.firstUpdatePass && function Cg(t, e, n, r) { const i = t.data; if (null === i[n + 1]) { const o = i[Ye()], s = function wg(t, e) { return e >= t.expandoStartIndex }(t, n); (function Ig(t, e) { return 0 != (t.flags & (e ? 16 : 32)) })(o, r) && null === e && !s && (e = !1), e = function FA(t, e, n, r) { const i = function Pl(t) { const e = L.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let o = r ? e.residualClasses : e.residualStyles; if (null === i) 0 === (r ? e.classBindings : e.styleBindings) && (n = Yi(n = dc(null, t, e, n, r), e.attrs, r), o = null); else { const s = e.directiveStylingLast; if (-1 === s || t[s] !== i) if (n = dc(i, t, e, n, r), null === o) { let l = function xA(t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== Mn(r)) return t[Ut(r)] }(t, e, r); void 0 !== l && Array.isArray(l) && (l = dc(null, t, e, l[1], r), l = Yi(l, e.attrs, r), function NA(t, e, n, r) { t[Ut(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, l)) } else o = function kA(t, e, n) { let r; const i = e.directiveEnd; for (let o = 1 + e.directiveStylingLast; o < i; o++)r = Yi(r, t[o].hostAttrs, n); return Yi(r, e.attrs, n) }(t, e, r) } return void 0 !== o && (r ? e.residualClasses = o : e.residualStyles = o), n }(i, o, e, r), function vA(t, e, n, r, i, o) { let s = o ? e.classBindings : e.styleBindings, a = Ut(s), l = Mn(s); t[r] = n; let c, u = !1; if (Array.isArray(n)) { const d = n; c = d[1], (null === c || Vr(d, c) > 0) && (u = !0) } else c = n; if (i) if (0 !== l) { const f = Ut(t[a + 1]); t[r + 1] = Ms(f, a), 0 !== f && (t[f + 1] = Pu(t[f + 1], r)), t[a + 1] = function a0(t, e) { return 131071 & t | e << 17 }(t[a + 1], r) } else t[r + 1] = Ms(a, 0), 0 !== a && (t[a + 1] = Pu(t[a + 1], r)), a = r; else t[r + 1] = Ms(l, 0), 0 === a ? a = r : t[l + 1] = Pu(t[l + 1], r), l = r; u && (t[r + 1] = Ou(t[r + 1])), mg(t, c, r, !0), mg(t, c, r, !1), function bA(t, e, n, r, i) { const o = i ? t.residualClasses : t.residualStyles; null != o && "string" == typeof e && Vr(o, e) >= 0 && (n[r + 1] = Ru(n[r + 1])) }(e, c, t, r, o), s = Ms(a, l), o ? e.classBindings = s : e.styleBindings = s }(i, o, e, n, s, r) } }(o, t, s, r), e !== B && Ue(i, s, e) && function Ag(t, e, n, r, i, o, s, a) { if (!(3 & e.type)) return; const l = t.data, u = l[a + 1]; Os(function tm(t) { return 1 == (1 & t) }(u) ? Tg(l, e, n, i, Mn(u), s) : void 0) || (Os(o) || function em(t) { return 2 == (2 & t) }(u) && (o = Tg(l, null, n, i, a, s)), function vM(t, e, n, r, i) { const o = _e(t); if (e) i ? o ? t.addClass(n, r) : n.classList.add(r) : o ? t.removeClass(n, r) : n.classList.remove(r); else { let s = -1 === r.indexOf("-") ? void 0 : pt.DashCase; if (null == i) o ? t.removeStyle(n, r, s) : n.style.removeProperty(r); else { const a = "string" == typeof i && i.endsWith("!important"); a && (i = i.slice(0, -10), s |= pt.Important), o ? t.setStyle(n, r, i, s) : n.style.setProperty(r, i, a ? "important" : "") } } }(r, s, Ko(Ye(), n), i, o)) }(o, o.data[Ye()], i, i[$], t, i[s + 1] = function RA(t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = ie(function Ln(t) { return t instanceof class Gh { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } ? t.changingThisBreaksApplicationSecurity : t }(t)))), t }(e, n), r, s) }(t, e, null, !0), zt } function dc(t, e, n, r, i) { let o = null; const s = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < s && (o = e[a], r = Yi(r, o.hostAttrs, i), o !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function Yi(t, e, n) { const r = n ? 1 : 2; let i = -1; if (null !== e) for (let o = 0; o < e.length; o++) { const s = e[o]; "number" == typeof s ? i = s : i === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), ht(t, s, !!n || e[++o])) } return void 0 === t ? null : t } function Tg(t, e, n, r, i, o) { const s = null === e; let a; for (; i > 0;) { const l = t[i], u = Array.isArray(l), c = u ? l[1] : l, d = null === c; let f = n[i + 1]; f === B && (f = d ? J : void 0); let h = d ? Wl(f, r) : c === r ? f : void 0; if (u && !Os(h) && (h = Wl(l, r)), Os(h) && (a = h, s)) return a; const p = t[i + 1]; i = s ? Ut(p) : Mn(p) } if (null !== e) { let l = o ? e.residualClasses : e.residualStyles; null != l && (a = Wl(l, r)) } return a } function Os(t) { return void 0 !== t } function jn(t, e = "") { const n = b(), r = K(), i = t + 22, o = r.firstCreatePass ? qr(r, i, 1, e, null) : r.data[i], s = n[i] = function pu(t, e) { return _e(t) ? t.createText(e) : t.createTextNode(e) }(n[$], e); Ds(r, n, s, o), en(o, !1) } function Ps(t) { return fc("", t, ""), Ps } function fc(t, e, n) { const r = b(), i = function Zr(t, e, n, r) { return Ue(t, Fr(), n) ? e + V(n) + r : B }(r, t, e, n); return i !== B && An(r, Ye(), i), fc } function hc(t, e, n) { const r = b(); return Ue(r, Fr(), e) && mt(K(), ve(), r, t, e, r[$], n, !0), hc } const si = "en-US"; let Qg = si; function gc(t, e, n, r, i) { if (t = P(t), Array.isArray(t)) for (let o = 0; o < t.length; o++)gc(t[o], e, n, r, i); else { const o = K(), s = b(); let a = or(t) ? t : P(t.provide), l = Gp(t); const u = Te(), c = 1048575 & u.providerIndexes, d = u.directiveStart, f = u.providerIndexes >> 20; if (or(t) || !t.multi) { const h = new Ai(l, i, v), p = _c(a, e, i ? c : c + f, d); -1 === p ? (os(Ii(u, s), o, a), yc(o, t, e.length), e.push(a), u.directiveStart++, u.directiveEnd++, i && (u.providerIndexes += 1048576), n.push(h), s.push(h)) : (n[p] = h, s[p] = h) } else { const h = _c(a, e, c + f, d), p = _c(a, e, c, c + f), m = h >= 0 && n[h], y = p >= 0 && n[p]; if (i && !y || !i && !m) { os(Ii(u, s), o, a); const _ = function eI(t, e, n, r, i) { const o = new Ai(t, n, v); return o.multi = [], o.index = e, o.componentProviders = 0, by(o, i, r && !n), o }(i ? JT : XT, n.length, i, r, l); !i && y && (n[p].providerFactory = _), yc(o, t, e.length, 0), e.push(a), u.directiveStart++, u.directiveEnd++, i && (u.providerIndexes += 1048576), n.push(_), s.push(_) } else yc(o, t, h > -1 ? h : p, by(n[i ? p : h], l, !i && r)); !i && r && y && n[p].componentProviders++ } } } function yc(t, e, n, r) { const i = or(e), o = function VM(t) { return !!t.useClass }(e); if (i || o) { const l = (o ? P(e.useClass) : e).prototype.ngOnDestroy; if (l) { const u = t.destroyHooks || (t.destroyHooks = []); if (!i && e.multi) { const c = u.indexOf(n); -1 === c ? u.push(n, [r, l]) : u[c + 1].push(r, l) } else u.push(n, l) } } } function by(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function _c(t, e, n, r) { for (let i = n; i < r; i++)if (e[i] === t) return i; return -1 } function XT(t, e, n, r) { return vc(this.multi, []) } function JT(t, e, n, r) { const i = this.multi; let o; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Si(n, n[1], this.providerFactory.index, r); o = a.slice(0, s), vc(i, o); for (let l = s; l < a.length; l++)o.push(a[l]) } else o = [], vc(i, o); return o } function vc(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function le(t, e = []) { return n => { n.providersResolver = (r, i) => function YT(t, e, n) { const r = K(); if (r.firstCreatePass) { const i = jt(t); gc(n, r.data, r.blueprint, i, !0), gc(e, r.data, r.blueprint, i, !1) } }(r, i ? i(t) : t, e) } } class nI { resolveComponentFactory(e) { throw function tI(t) { const e = Error(`No component factory found for ${ie(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(e) } } let js = (() => { class t { } return t.NULL = new nI, t })(); class ur { } class Ey { } function oI() { return li(Te(), b()) } function li(t, e) { return new Ve(Ct(t, e)) } let Ve = (() => { class t { constructor(n) { this.nativeElement = n } } return t.__NG_ELEMENT_ID__ = oI, t })(); function sI(t) { return t instanceof Ve ? t.nativeElement : t } class no { } let cr = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => function lI() { const t = b(), n = dt(Te().index, t); return function aI(t) { return t[$] }(rt(n) ? n : t) }(), t })(), uI = (() => { class t { } return t.\u0275prov = G({ token: t, providedIn: "root", factory: () => null }), t })(); class ui { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const cI = new ui("14.0.0"), bc = {}; function Hs(t, e, n, r, i = !1) { for (; null !== n;) { const o = e[n.index]; if (null !== o && r.push(we(o)), Bt(o)) for (let a = 10; a < o.length; a++) { const l = o[a], u = l[1].firstChild; null !== u && Hs(l[1], l, u, r) } const s = n.type; if (8 & s) Hs(t, e, n.child, r); else if (32 & s) { const a = du(n, e); let l; for (; l = a();)r.push(l) } else if (16 & s) { const a = wp(e, n); if (Array.isArray(a)) r.push(...a); else { const l = $i(e[16]); Hs(l[1], l, a, r, !0) } } n = i ? n.projectionNext : n.next } return r } class ro { constructor(e, n) { this._lView = e, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const e = this._lView, n = e[1]; return Hs(n, e, n.firstChild, []) } get context() { return this._lView[8] } set context(e) { this._lView[8] = e } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const e = this._lView[3]; if (Bt(e)) { const n = e[8], r = n ? n.indexOf(this) : -1; r > -1 && (gu(e, r), as(n, r)) } this._attachedToViewContainer = !1 } hp(this._lView[1], this._lView) } onDestroy(e) { _m(this._lView[1], this._lView, null, e) } markForCheck() { Xu(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { !function ec(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Kr(t, e, t.template, n) } catch (i) { throw xm(e, i), i } finally { r.end && r.end() } }(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new w(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function uM(t, e) { Ui(t, e, e[$], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new w(902, ""); this._appRef = e } } class dI extends ro { constructor(e) { super(e), this._view = e } detectChanges() { Tm(this._view) } checkNoChanges() { } get context() { return null } } class Dc extends js { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { const n = oe(e); return new Ec(n, this.ngModule) } } function wy(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } class hI { constructor(e, n) { this.injector = e, this.parentInjector = n } get(e, n, r) { const i = this.injector.get(e, bc, r); return i !== bc || n === bc ? i : this.parentInjector.get(e, n, r) } } class Ec extends Ey { constructor(e, n) { super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = function SM(t) { return t.map(IM).join(",") }(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return wy(this.componentDef.inputs) } get outputs() { return wy(this.componentDef.outputs) } create(e, n, r, i) { let o = (i = i || this.ngModule) instanceof Gi ? i : i?.injector; o && null !== this.componentDef.getStandaloneInjector && (o = this.componentDef.getStandaloneInjector(o) || o); const s = o ? new hI(e, o) : e, a = s.get(no, eh), l = s.get(uI, null), u = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function ym(t, e, n) { if (_e(t)) return t.selectRootElement(e, n === Lt.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(u, r, this.componentDef.encapsulation) : mu(a.createRenderer(null, this.componentDef), c, function fI(t) { const e = t.toLowerCase(); return "svg" === e ? "svg" : "math" === e ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = function Um(t, e) { return { components: [], scheduler: t || eM, clean: G0, playerHandler: e || null, flags: 0 } }(), p = Is(0, null, null, 1, 0, null, null, null, null, null), m = zi(null, p, h, f, null, null, a, u, l, s, null); let y, _; Zo(m); try { const D = function Hm(t, e, n, r, i, o) { const s = n[1]; n[22] = t; const l = qr(s, 22, 2, "#host", null), u = l.mergedAttrs = e.hostAttrs; null !== u && (Fs(l, u, !0), null !== t && (ts(i, t, u), null !== l.classes && Du(i, t, l.classes), null !== l.styles && Ap(i, t, l.styles))); const c = r.createRenderer(t, e), d = zi(n, mm(e), null, e.onPush ? 32 : 16, n[22], l, r, c, o || null, null, null); return s.firstCreatePass && (os(Ii(l, n), s, e.type), wm(s, l), Cm(l, n.length, 1)), Ss(n, d), n[22] = d }(d, this.componentDef, m, a, u); if (d) if (r) ts(u, d, ["ng-version", cI.full]); else { const { attrs: g, classes: E } = function FM(t) { const e = [], n = []; let r = 1, i = 2; for (; r < t.length;) { let o = t[r]; if ("string" == typeof o) 2 === i ? "" !== o && e.push(o, t[++r]) : 8 === i && n.push(o); else { if (!Ht(i)) break; i = o } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); g && ts(u, d, g), E && E.length > 0 && Du(u, d, E.join(" ")) } if (_ = Tl(p, 22), void 0 !== n) { const g = _.projection = []; for (let E = 0; E < this.ngContentSelectors.length; E++) { const j = n[E]; g.push(null != j ? Array.from(j) : null) } } y = function $m(t, e, n, r, i) { const o = n[1], s = function I0(t, e, n) { const r = Te(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), Mm(t, r, e, Wr(t, e, 1, null), n)); const i = Si(e, t, r.directiveStart, r); $e(i, e); const o = Ct(r, e); return o && $e(o, e), i }(o, n, e); if (r.components.push(s), t[8] = s, i && i.forEach(l => l(s, e)), e.contentQueries) { const l = Te(); e.contentQueries(1, s, l.directiveStart) } const a = Te(); return !o.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (Pn(a.index), Dm(n[1], a, 0, a.directiveStart, a.directiveEnd, e), Em(e, s)), s }(D, this.componentDef, m, h, [tA]), qi(p, m, null) } finally { Yo() } return new mI(this.componentType, y, li(_, m), m, _) } } class mI extends class iI { }{ constructor(e, n, r, i, o) { super(), this.location = r, this._rootLView = i, this._tNode = o, this.instance = n, this.hostView = this.changeDetectorRef = new dI(i), this.componentType = e } get injector() { return new kr(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } } class Cy extends ur { constructor(e, n) { super(), this._parent = n, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Dc(this); const r = function ut(t, e) { const n = t[zf] || null; if (!n && !0 === e) throw new Error(`Type ${ie(t)} does not have '\u0275mod' property.`); return n }(e); this._bootstrapComponents = function Cn(t) { return t instanceof Function ? t() : t }(r.bootstrap), this._r3Injector = qp(e, n, [{ provide: ur, useValue: this }, { provide: js, useValue: this.componentFactoryResolver }], ie(e), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this.get(e) } get(e, n = $t.THROW_IF_NOT_FOUND, r = R.Default) { return e === $t || e === ur || e === Cu ? this : this._r3Injector.get(e, n, r) } destroy() { const e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } } class wc extends class rI { }{ constructor(e) { super(), this.moduleType = e } create(e) { return new Cy(this.moduleType, e) } } function Cc(t) { return e => { setTimeout(t, void 0, e) } } const ke = class VI extends Ot { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, n, r) { let i = e, o = n || (() => null), s = r; if (e && "object" == typeof e) { const l = e; i = l.next?.bind(l), o = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (o = Cc(o), i && (i = Cc(i)), s && (s = Cc(s))); const a = super.subscribe({ next: i, error: o, complete: s }); return e instanceof kt && e.add(a), a } }; function BI() { return this._results[sr()]() } class Mc { constructor(e = !1) { this._emitDistinctChangesOnly = e, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const n = sr(), r = Mc.prototype; r[n] || (r[n] = BI) } get changes() { return this._changes || (this._changes = new ke) } get(e) { return this._results[e] } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, n) { return this._results.reduce(e, n) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e, n) { const r = this; r.dirty = !1; const i = ft(e); (this._changesDetected = !function kw(t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let i = t[r], o = e[r]; if (n && (i = n(i), o = n(o)), o !== i) return !1 } return !0 }(r._results, i, n)) && (r._results = i, r.length = i.length, r.last = i[this.length - 1], r.first = i[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Tn = (() => { class t { } return t.__NG_ELEMENT_ID__ = $I, t })(); const jI = Tn, HI = class extends jI { constructor(e, n, r) { super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(e, n) { const r = this._declarationTContainer.tViews, i = zi(this._declarationLView, r, e, 16, null, r.declTNode, null, null, null, null, n || null); i[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (i[19] = s.createEmbeddedView(r)), qi(r, i, e), new ro(i) } }; function $I() { return $s(Te(), b()) } function $s(t, e) { return 4 & t.type ? new HI(e, t, li(t, e)) : null } let dn = (() => { class t { } return t.__NG_ELEMENT_ID__ = UI, t })(); function UI() { return ky(Te(), b()) } const GI = dn, xy = class extends GI { constructor(e, n, r) { super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r } get element() { return li(this._hostTNode, this._hostLView) } get injector() { return new kr(this._hostTNode, this._hostLView) } get parentInjector() { const e = is(this._hostTNode, this._hostLView); if (yh(e)) { const n = Nr(e, this._hostLView), r = xr(e); return new kr(n[1].data[r + 8], n) } return new kr(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { const n = Ny(this._lContainer); return null !== n && n[e] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(e, n, r) { let i, o; "number" == typeof r ? i = r : null != r && (i = r.index, o = r.injector); const s = e.createEmbeddedView(n || {}, o); return this.insert(s, i), s } createComponent(e, n, r, i, o) { const s = e && !function xi(t) { return "function" == typeof t }(e); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, i = d.projectableNodes, o = d.environmentInjector || d.ngModuleRef } const l = s ? e : new Ec(oe(e)), u = r || this.parentInjector; if (!o && null == l.ngModule) { const f = (s ? u : this.parentInjector).get(Gi, null); f && (o = f) } const c = l.create(u, i, void 0, o); return this.insert(c.hostView, a), c } insert(e, n) { const r = e._lView, i = r[1]; if (function ew(t) { return Bt(t[3]) }(r)) { const c = this.indexOf(e); if (-1 !== c) this.detach(c); else { const d = r[3], f = new xy(d, d[6], d[3]); f.detach(f.indexOf(e)) } } const o = this._adjustIndex(n), s = this._lContainer; !function dM(t, e, n, r) { const i = 10 + r, o = n.length; r > 0 && (n[i - 1][4] = e), r < o - 10 ? (e[4] = n[i], Ih(n, 10 + r, e)) : (n.push(e), e[4] = null), e[3] = n; const s = e[17]; null !== s && n !== s && function fM(t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(s, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 64 }(i, r, s, o); const a = vu(o, s), l = r[$], u = bs(l, s[7]); return null !== u && function lM(t, e, n, r, i, o) { r[0] = i, r[6] = e, Ui(t, r, n, 1, i, o) }(i, s[6], l, r, u, a), e.attachToViewContainerRef(), Ih(Ac(s), o, e), e } move(e, n) { return this.insert(e, n) } indexOf(e) { const n = Ny(this._lContainer); return null !== n ? n.indexOf(e) : -1 } remove(e) { const n = this._adjustIndex(e, -1), r = gu(this._lContainer, n); r && (as(Ac(this._lContainer), n), hp(r[1], r)) } detach(e) { const n = this._adjustIndex(e, -1), r = gu(this._lContainer, n); return r && null != as(Ac(this._lContainer), n) ? new ro(r) : null } _adjustIndex(e, n = 0) { return e ?? this.length + n } }; function Ny(t) { return t[8] } function Ac(t) { return t[8] || (t[8] = []) } function ky(t, e) { let n; const r = e[t.index]; if (Bt(r)) n = r; else { let i; if (8 & t.type) i = we(r); else { const o = e[$]; i = o.createComment(""); const s = Ct(t, e); ir(o, bs(o, s), i, function gM(t, e) { return _e(t) ? t.nextSibling(e) : e.nextSibling }(o, s), !1) } e[t.index] = n = Am(r, e, i, t), Ss(e, n) } return new xy(n, t, e) } class Tc { constructor(e) { this.queryList = e, this.matches = null } clone() { return new Tc(this.queryList) } setDirty() { this.queryList.setDirty() } } class Ic { constructor(e = []) { this.queries = e } createEmbeddedView(e) { const n = e.queries; if (null !== n) { const r = null !== e.contentQueries ? e.contentQueries[0] : n.length, i = []; for (let o = 0; o < r; o++) { const s = n.getByIndex(o); i.push(this.queries[s.indexInDeclarationView].clone()) } return new Ic(i) } return null } insertView(e) { this.dirtyQueriesWithMatches(e) } detachView(e) { this.dirtyQueriesWithMatches(e) } dirtyQueriesWithMatches(e) { for (let n = 0; n < this.queries.length; n++)null !== Vy(e, n).matches && this.queries[n].setDirty() } } class Oy { constructor(e, n, r = null) { this.predicate = e, this.flags = n, this.read = r } } class Sc { constructor(e = []) { this.queries = e } elementStart(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(e, n) } elementEnd(e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementEnd(e) } embeddedTView(e) { let n = null; for (let r = 0; r < this.length; r++) { const i = null !== n ? n.length : 0, o = this.getByIndex(r).embeddedTView(e, i); o && (o.indexInDeclarationView = r, null !== n ? n.push(o) : n = [o]) } return null !== n ? new Sc(n) : null } template(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(e, n) } getByIndex(e) { return this.queries[e] } get length() { return this.queries.length } track(e) { this.queries.push(e) } } class Fc { constructor(e, n = -1) { this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n } elementStart(e, n) { this.isApplyingToNode(n) && this.matchTNode(e, n) } elementEnd(e) { this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1) } template(e, n) { this.elementStart(e, n) } embeddedTView(e, n) { return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, n), new Fc(this.metadata)) : null } isApplyingToNode(e) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const n = this._declarationNodeIndex; let r = e.parent; for (; null !== r && 8 & r.type && r.index !== n;)r = r.parent; return n === (null !== r ? r.index : -1) } return this._appliesToNextNode } matchTNode(e, n) { const r = this.metadata.predicate; if (Array.isArray(r)) for (let i = 0; i < r.length; i++) { const o = r[i]; this.matchTNodeWithReadOption(e, n, WI(n, o)), this.matchTNodeWithReadOption(e, n, ss(n, e, o, !1, !1)) } else r === Tn ? 4 & n.type && this.matchTNodeWithReadOption(e, n, -1) : this.matchTNodeWithReadOption(e, n, ss(n, e, r, !1, !1)) } matchTNodeWithReadOption(e, n, r) { if (null !== r) { const i = this.metadata.read; if (null !== i) if (i === Ve || i === dn || i === Tn && 4 & n.type) this.addMatch(n.index, -2); else { const o = ss(n, e, i, !1, !1); null !== o && this.addMatch(n.index, o) } else this.addMatch(n.index, r) } } addMatch(e, n) { null === this.matches ? this.matches = [e, n] : this.matches.push(e, n) } } function WI(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function QI(t, e, n, r) { return -1 === n ? function KI(t, e) { return 11 & t.type ? li(t, e) : 4 & t.type ? $s(t, e) : null }(e, t) : -2 === n ? function ZI(t, e, n) { return n === Ve ? li(e, t) : n === Tn ? $s(e, t) : n === dn ? ky(e, t) : void 0 }(t, e, r) : Si(t, t[1], n, e) } function Py(t, e, n, r) { const i = e[19].queries[r]; if (null === i.matches) { const o = t.data, s = n.matches, a = []; for (let l = 0; l < s.length; l += 2) { const u = s[l]; a.push(u < 0 ? null : QI(e, o[u], s[l + 1], n.metadata.read)) } i.matches = a } return i.matches } function xc(t, e, n, r) { const i = t.queries.getByIndex(n), o = i.matches; if (null !== o) { const s = Py(t, e, i, n); for (let a = 0; a < o.length; a += 2) { const l = o[a]; if (l > 0) r.push(s[a / 2]); else { const u = o[a + 1], c = e[-l]; for (let d = 10; d < c.length; d++) { const f = c[d]; f[17] === f[3] && xc(f[1], f, u, r) } if (null !== c[9]) { const d = c[9]; for (let f = 0; f < d.length; f++) { const h = d[f]; xc(h[1], h, u, r) } } } } } return r } function it(t) { const e = b(), n = K(), r = lh(); Rl(r + 1); const i = Vy(n, r); if (t.dirty && th(e) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) t.reset([]); else { const o = i.crossesNgTemplate ? xc(n, e, r, []) : Py(n, e, i, r); t.reset(o, sI), t.notifyOnChanges() } return !0 } return !1 } function so(t, e, n) { const r = K(); r.firstCreatePass && (Ly(r, new Oy(t, e, n), -1), 2 == (2 & e) && (r.staticViewQueries = !0)), Ry(r, b(), e) } function fn(t, e, n, r) { const i = K(); if (i.firstCreatePass) { const o = Te(); Ly(i, new Oy(e, n, r), o.index), function XI(t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(i, t), 2 == (2 & n) && (i.staticContentQueries = !0) } Ry(i, b(), n) } function ot() { return function YI(t, e) { return t[19].queries[e].queryList }(b(), lh()) } function Ry(t, e, n) { const r = new Mc(4 == (4 & n)); _m(t, e, r, r.destroy), null === e[19] && (e[19] = new Ic), e[19].queries.push(new Tc(r)) } function Ly(t, e, n) { null === t.queries && (t.queries = new Sc), t.queries.track(new Fc(e, n)) } function Vy(t, e) { return t.queries.getByIndex(e) } function Gs(...t) { } const r_ = new I("Application Initializer"); let zs = (() => { class t { constructor(n) { this.appInits = n, this.resolve = Gs, this.reject = Gs, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => { this.resolve = r, this.reject = i }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const o = this.appInits[i](); if (ks(o)) n.push(o); else if (ng(o)) { const s = new Promise((a, l) => { o.subscribe({ complete: a, error: l }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(i => { this.reject(i) }), 0 === n.length && r(), this.initialized = !0 } } return t.\u0275fac = function (n) { return new (n || t)(S(r_, 8)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const uo = new I("AppId", { providedIn: "root", factory: function i_() { return `${Rc()}${Rc()}${Rc()}` } }); function Rc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const o_ = new I("Platform Initializer"), Lc = new I("Platform ID", { providedIn: "platform", factory: () => "unknown" }), vS = new I("appBootstrapListener"), co = new I("AnimationModuleType"), hn = new I("LocaleId", { providedIn: "root", factory: () => Zl(hn, R.Optional | R.SkipSelf) || function bS() { return typeof $localize < "u" && $localize.locale || si }() }), CS = (() => Promise.resolve(0))(); function Vc(t) { typeof Zone > "u" ? CS.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class ue { constructor({ enableLongStackTrace: e = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ke(!1), this.onMicrotaskEmpty = new ke(!1), this.onStable = new ke(!1), this.onError = new ke(!1), typeof Zone > "u") throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function MS() { let t = ne.requestAnimationFrame, e = ne.cancelAnimationFrame; if (typeof Zone < "u" && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function IS(t) { const e = () => { !function TS(t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(ne, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, jc(t), t.isCheckStableRunning = !0, Bc(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), jc(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, o, s, a) => { try { return s_(t), n.invokeTask(i, o, s, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === o.type || t.shouldCoalesceRunChangeDetection) && e(), a_(t) } }, onInvoke: (n, r, i, o, s, a, l) => { try { return s_(t), n.invoke(i, o, s, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), a_(t) } }, onHasTask: (n, r, i, o) => { n.hasTask(i, o), r === i && ("microTask" == o.change ? (t._hasPendingMicrotasks = o.microTask, jc(t), Bc(t)) : "macroTask" == o.change && (t.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (n, r, i, o) => (n.handleError(i, o), t.runOutsideAngular(() => t.onError.emit(o)), !1) }) }(i) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!ue.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (ue.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, n, r) { return this._inner.run(e, n, r) } runTask(e, n, r, i) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + i, e, AS, Gs, Gs); try { return o.runTask(s, n, r) } finally { o.cancelTask(s) } } runGuarded(e, n, r) { return this._inner.runGuarded(e, n, r) } runOutsideAngular(e) { return this._outer.run(e) } } const AS = {}; function Bc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function jc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function s_(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function a_(t) { t._nesting--, Bc(t) } class SS { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ke, this.onMicrotaskEmpty = new ke, this.onStable = new ke, this.onError = new ke } run(e, n, r) { return e.apply(n, r) } runGuarded(e, n, r) { return e.apply(n, r) } runOutsideAngular(e) { return e() } runTask(e, n, r, i) { return e.apply(n, r) } } const l_ = new I(""), qs = new I(""); let Uc, Hc = (() => { class t { constructor(n, r, i) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Uc || (function FS(t) { Uc = t }(i), i.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { ue.assertNotInAngularZone(), Vc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Vc(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, i) { let o = -1; r && r > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: o, updateCb: i }) } whenStable(n, r, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, i) { return [] } } return t.\u0275fac = function (n) { return new (n || t)(S(ue), S($c), S(qs)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(), $c = (() => { class t { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Uc?.findTestabilityInTree(this, n, r) ?? null } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(), Hn = null; const u_ = new I("AllowMultipleToken"), c_ = new I("PlatformOnDestroy"); function f_(t, e, n = []) { const r = `Platform: ${e}`, i = new I(r); return (o = []) => { let s = Gc(); if (!s || s.injector.get(u_, !1)) { const a = [...n, ...o, { provide: i, useValue: !0 }]; t ? t(a) : function kS(t) { if (Hn && !Hn.get(u_, !1)) throw new w(400, ""); Hn = t; const e = t.get(p_); (function d_(t) { const e = t.get(o_, null); e && e.forEach(n => n()) })(t) }(function h_(t = [], e) { return $t.create({ name: e, providers: [{ provide: Mu, useValue: "platform" }, { provide: c_, useValue: () => Hn = null }, ...t] }) }(a, r)) } return function PS(t) { const e = Gc(); if (!e) throw new w(401, ""); return e }() } } function Gc() { return Hn?.get(p_) ?? null } let p_ = (() => { class t { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const i = function RS(t, e) { let n; return n = "noop" === t ? new SS : ("zone.js" === t ? void 0 : t) || new ue(e), n }(r?.ngZone, function m_(t) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!t || !t.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!t || !t.ngZoneRunCoalescing) || !1 } }(r)), o = [{ provide: ue, useValue: i }]; return i.run(() => { const s = $t.create({ providers: o, parent: this.injector, name: n.moduleType.name }), a = n.create(s), l = a.injector.get(Hr, null); if (!l) throw new w(402, ""); return i.runOutsideAngular(() => { const u = i.onError.subscribe({ next: c => { l.handleError(c) } }); a.onDestroy(() => { Ws(this._modules, a), u.unsubscribe() }) }), function g_(t, e, n) { try { const r = n(); return ks(r) ? r.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(l, i, () => { const u = a.injector.get(zs); return u.runInitializers(), u.donePromise.then(() => (function Zg(t) { lt(t, "Expected localeId to be defined"), "string" == typeof t && (Qg = t.toLowerCase().replace(/_/g, "-")) }(a.injector.get(hn, si) || si), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const i = y_({}, r); return function xS(t, e, n) { const r = new wc(n); return Promise.resolve(r) }(0, 0, n).then(o => this.bootstrapModuleFactory(o, i)) } _moduleDoBootstrap(n) { const r = n.injector.get(zc); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(i => r.bootstrap(i)); else { if (!n.instance.ngDoBootstrap) throw new w(403, ""); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new w(404, ""); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()), this._injector.get(c_, null)?.(), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (n) { return new (n || t)(S($t)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "platform" }), t })(); function y_(t, e) { return Array.isArray(e) ? e.reduce(y_, t) : { ...t, ...e } } let zc = (() => { class t { constructor(n, r, i, o) { this._zone = n, this._injector = r, this._exceptionHandler = i, this._initStatus = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const s = new Pe(l => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { l.next(this._stable), l.complete() }) }), a = new Pe(l => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { ue.assertNotInAngularZone(), Vc(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, l.next(!0)) }) }) }); const c = this._zone.onUnstable.subscribe(() => { ue.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { l.next(!1) })) }); return () => { u.unsubscribe(), c.unsubscribe() } }); this.isStable = Bf(s, a.pipe(function DE(t = {}) { const { connector: e = (() => new Ot), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: i = !0 } = t; return o => { let s = null, a = null, l = null, u = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = null }, h = () => { f(), s = l = null, c = d = !1 }, p = () => { const m = s; h(), m?.unsubscribe() }; return Pt((m, y) => { u++, !d && !c && f(); const _ = l = l ?? e(); y.add(() => { u--, 0 === u && !d && !c && (a = ul(p, i)) }), _.subscribe(y), s || (s = new Po({ next: D => _.next(D), error: D => { d = !0, f(), a = ul(h, n, D), _.error(D) }, complete: () => { c = !0, f(), a = ul(h, r), _.complete() } }), vi(m).subscribe(s)) })(o) } }())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const i = n instanceof Ey; if (!this._initStatus.done) throw !i && function lo(t) { const e = oe(t) || We(t) || Ke(t); return null !== e && e.standalone }(n), new w(405, false); let o; o = i ? n : this._injector.get(js).resolveComponentFactory(n), this.componentTypes.push(o.componentType); const s = function NS(t) { return t.isBoundToModule }(o) ? void 0 : this._injector.get(ur), l = o.create($t.NULL, [], r || o.selector, s), u = l.location.nativeElement, c = l.injector.get(l_, null); return c?.registerApplication(u), l.onDestroy(() => { this.detachView(l.hostView), Ws(this.components, l), c?.unregisterApplication(u) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new w(101, ""); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; Ws(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(vS, []).concat(this._bootstrapListeners).forEach(i => i(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => Ws(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new w(406, false); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return t.\u0275fac = function (n) { return new (n || t)(S(ue), S($t), S(Hr), S(zs)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Ws(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } let v_ = !0, Ks = (() => { class t { } return t.__NG_ELEMENT_ID__ = BS, t })(); function BS(t) { return function jS(t, e, n) { if (qo(t) && !n) { const r = dt(t.index, e); return new ro(r, r) } return 47 & t.type ? new ro(e[16], e) : null }(Te(), b(), 16 == (16 & t)) } const JS = f_(null, "core", []); let eF = (() => { class t { constructor(n) { } } return t.\u0275fac = function (n) { return new (n || t)(S(zc)) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({}), t })(), Xs = null; function fr() { return Xs } const Be = new I("DocumentToken"); let H_ = (() => { class t { constructor(n, r) { this._viewContainer = n, this._context = new QF, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { $_("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { $_("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } } return t.\u0275fac = function (n) { return new (n || t)(v(dn), v(Tn)) }, t.\u0275dir = N({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class QF { constructor() { this.$implicit = null, this.ngIf = null } } function $_(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${ie(e)}'.`) } class sd { constructor(e, n) { this._viewContainerRef = e, this._templateRef = n, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(e) { e && !this._created ? this.create() : !e && this._created && this.destroy() } } let la = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(n) { this._ngSwitch = n, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(n) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(n) } _matchCase(n) { const r = n == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || r, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), r } _updateDefaultCases(n) { if (this._defaultViews && n !== this._defaultUsed) { this._defaultUsed = n; for (let r = 0; r < this._defaultViews.length; r++)this._defaultViews[r].enforceState(n) } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = N({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), U_ = (() => { class t { constructor(n, r, i) { this.ngSwitch = i, i._addCase(), this._view = new sd(n, r) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (n) { return new (n || t)(v(dn), v(Tn), v(la, 9)) }, t.\u0275dir = N({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(), q_ = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({}), t })(); const W_ = "browser"; class ud extends class Tx extends class rF { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function nF(t) { Xs || (Xs = t) }(new ud) } onAndCancel(e, n, r) { return e.addEventListener(n, r, !1), () => { e.removeEventListener(n, r, !1) } } dispatchEvent(e, n) { e.dispatchEvent(n) } remove(e) { e.parentNode && e.parentNode.removeChild(e) } createElement(e, n) { return (n = n || this.getDefaultDocument()).createElement(e) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } isShadowRoot(e) { return e instanceof DocumentFragment } getGlobalEventTarget(e, n) { return "window" === n ? window : "document" === n ? e : "body" === n ? e.body : null } getBaseHref(e) { const n = function Ix() { return mo = mo || document.querySelector("base"), mo ? mo.getAttribute("href") : null }(); return null == n ? null : function Sx(t) { ua = ua || document.createElement("a"), ua.setAttribute("href", t); const e = ua.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(n) } resetBaseElement() { mo = null } getUserAgent() { return window.navigator.userAgent } getCookie(e) { return function GF(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const r = n.indexOf("="), [i, o] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (i.trim() === e) return decodeURIComponent(o) } return null }(document.cookie, e) } } let ua, mo = null; const Q_ = new I("TRANSITION_ID"), xx = [{ provide: r_, useFactory: function Fx(t, e, n) { return () => { n.get(zs).donePromise.then(() => { const r = fr(), i = e.querySelectorAll(`style[ng-transition="${t}"]`); for (let o = 0; o < i.length; o++)r.remove(i[o]) }) } }, deps: [Q_, Be, $t], multi: !0 }]; let kx = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); const ca = new I("EventManagerPlugins"); let da = (() => { class t { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(i => i.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, i) { return this._findPluginFor(r).addEventListener(n, r, i) } addGlobalEventListener(n, r, i) { return this._findPluginFor(r).addGlobalEventListener(n, r, i) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const i = this._plugins; for (let o = 0; o < i.length; o++) { const s = i[o]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return t.\u0275fac = function (n) { return new (n || t)(S(ca), S(ue)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); class Z_ { constructor(e) { this._doc = e } addGlobalEventListener(e, n, r) { const i = fr().getGlobalEventTarget(this._doc, e); if (!i) throw new Error(`Unsupported event target ${i} for event ${n}`); return this.addEventListener(i, n, r) } } let Y_ = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(i => { this._stylesSet.has(i) || (this._stylesSet.add(i), r.add(i)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(), go = (() => { class t extends Y_ { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, i) { n.forEach(o => { const s = this._doc.createElement("style"); s.textContent = o, i.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(X_), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, i) => { this._addStylesToHost(n, i, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(X_)) } } return t.\u0275fac = function (n) { return new (n || t)(S(Be)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); function X_(t) { fr().remove(t) } const cd = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, dd = /%COMP%/g; function fa(t, e, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; Array.isArray(i) ? fa(t, i, n) : (i = i.replace(dd, t), n.push(i)) } return n } function tv(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let ha = (() => { class t { constructor(n, r, i) { this.eventManager = n, this.sharedStylesHost = r, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new fd(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case Lt.Emulated: { let i = this.rendererByCompId.get(r.id); return i || (i = new Bx(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, i)), i.applyToHost(n), i } case 1: case Lt.ShadowDom: return new jx(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const i = fa(r.id, r.styles, []); this.sharedStylesHost.addStyles(i), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (n) { return new (n || t)(S(da), S(go), S(uo)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); class fd { constructor(e) { this.eventManager = e, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(e, n) { return n ? document.createElementNS(cd[n] || n, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, n) { (rv(e) ? e.content : e).appendChild(n) } insertBefore(e, n, r) { e && (rv(e) ? e.content : e).insertBefore(n, r) } removeChild(e, n) { e && e.removeChild(n) } selectRootElement(e, n) { let r = "string" == typeof e ? document.querySelector(e) : e; if (!r) throw new Error(`The selector "${e}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, n, r, i) { if (i) { n = i + ":" + n; const o = cd[i]; o ? e.setAttributeNS(o, n, r) : e.setAttribute(n, r) } else e.setAttribute(n, r) } removeAttribute(e, n, r) { if (r) { const i = cd[r]; i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`) } else e.removeAttribute(n) } addClass(e, n) { e.classList.add(n) } removeClass(e, n) { e.classList.remove(n) } setStyle(e, n, r, i) { i & (pt.DashCase | pt.Important) ? e.style.setProperty(n, r, i & pt.Important ? "important" : "") : e.style[n] = r } removeStyle(e, n, r) { r & pt.DashCase ? e.style.removeProperty(n) : e.style[n] = "" } setProperty(e, n, r) { e[n] = r } setValue(e, n) { e.nodeValue = n } listen(e, n, r) { return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, n, tv(r)) : this.eventManager.addEventListener(e, n, tv(r)) } } function rv(t) { return "TEMPLATE" === t.tagName && void 0 !== t.content } class Bx extends fd { constructor(e, n, r, i) { super(e), this.component = r; const o = fa(i + "-" + r.id, r.styles, []); n.addStyles(o), this.contentAttr = function Rx(t) { return "_ngcontent-%COMP%".replace(dd, t) }(i + "-" + r.id), this.hostAttr = function Lx(t) { return "_nghost-%COMP%".replace(dd, t) }(i + "-" + r.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, n) { const r = super.createElement(e, n); return super.setAttribute(r, this.contentAttr, ""), r } } class jx extends fd { constructor(e, n, r, i) { super(e), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const o = fa(i.id, i.styles, []); for (let s = 0; s < o.length; s++) { const a = document.createElement("style"); a.textContent = o[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, n) { return super.appendChild(this.nodeOrShadowRoot(e), n) } insertBefore(e, n, r) { return super.insertBefore(this.nodeOrShadowRoot(e), n, r) } removeChild(e, n) { return super.removeChild(this.nodeOrShadowRoot(e), n) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } let Hx = (() => { class t extends Z_ { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, i) { return n.addEventListener(r, i, !1), () => this.removeEventListener(n, r, i) } removeEventListener(n, r, i) { return n.removeEventListener(r, i) } } return t.\u0275fac = function (n) { return new (n || t)(S(Be)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); const iv = ["alt", "control", "meta", "shift"], Ux = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, ov = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, Gx = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let zx = (() => { class t extends Z_ { constructor(n) { super(n) } supports(n) { return null != t.parseEventName(n) } addEventListener(n, r, i) { const o = t.parseEventName(r), s = t.eventCallback(o.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => fr().onAndCancel(n, o.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), i = r.shift(); if (0 === r.length || "keydown" !== i && "keyup" !== i) return null; const o = t._normalizeKey(r.pop()); let s = ""; if (iv.forEach(l => { const u = r.indexOf(l); u > -1 && (r.splice(u, 1), s += l + ".") }), s += o, 0 != r.length || 0 === o.length) return null; const a = {}; return a.domEventName = i, a.fullKey = s, a } static getEventFullKey(n) { let r = "", i = function qx(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && ov.hasOwnProperty(e) && (e = ov[e])) } return Ux[e] || e }(n); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), iv.forEach(o => { o != i && Gx[o](n) && (r += o + ".") }), r += i, r } static eventCallback(n, r, i) { return o => { t.getEventFullKey(o) === n && i.runGuarded(() => r(o)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return t.\u0275fac = function (n) { return new (n || t)(S(Be)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); const Zx = f_(JS, "browser", [{ provide: Lc, useValue: W_ }, { provide: o_, useValue: function Wx() { ud.makeCurrent() }, multi: !0 }, { provide: Be, useFactory: function Qx() { return function ZE(t) { Ml = t }(document), document }, deps: [] }]), av = new I(""), lv = [{ provide: qs, useClass: class Nx { addToWindow(e) { ne.getAngularTestability = (r, i = !0) => { const o = e.findTestabilityInTree(r, i); if (null == o) throw new Error("Could not find testability for element."); return o }, ne.getAllAngularTestabilities = () => e.getAllTestabilities(), ne.getAllAngularRootElements = () => e.getAllRootElements(), ne.frameworkStabilizers || (ne.frameworkStabilizers = []), ne.frameworkStabilizers.push(r => { const i = ne.getAllAngularTestabilities(); let o = i.length, s = !1; const a = function (l) { s = s || l, o--, 0 == o && r(s) }; i.forEach(function (l) { l.whenStable(a) }) }) } findTestabilityInTree(e, n, r) { return null == n ? null : e.getTestability(n) ?? (r ? fr().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null) } }, deps: [] }, { provide: l_, useClass: Hc, deps: [ue, $c, qs] }, { provide: Hc, useClass: Hc, deps: [ue, $c, qs] }], uv = [{ provide: Mu, useValue: "root" }, { provide: Hr, useFactory: function Kx() { return new Hr }, deps: [] }, { provide: ca, useClass: Hx, multi: !0, deps: [Be, ue, Lc] }, { provide: ca, useClass: zx, multi: !0, deps: [Be] }, { provide: ha, useClass: ha, deps: [da, go, uo] }, { provide: no, useExisting: ha }, { provide: Y_, useExisting: go }, { provide: go, useClass: go, deps: [Be] }, { provide: da, useClass: da, deps: [ca, ue] }, { provide: class Ax { }, useClass: kx, deps: [] }, []]; let cv = (() => { class t { constructor(n) { } static withServerTransition(n) { return { ngModule: t, providers: [{ provide: uo, useValue: n.appId }, { provide: Q_, useExisting: uo }, xx] } } } return t.\u0275fac = function (n) { return new (n || t)(S(av, 12)) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ providers: [...uv, ...lv], imports: [q_, eF] }), t })(); typeof window < "u" && window; const { isArray: aN } = Array, { getPrototypeOf: lN, prototype: uN, keys: cN } = Object; const { isArray: hN } = Array; function hv(t) { return il(e => function pN(t, e) { return hN(e) ? t(...e) : t(e) }(t, e)) } function mN(t, e) { return t.reduce((n, r, i) => (n[r] = e[i], n), {}) } function gN(...t) { const e = function hE(t) { return ee(ll(t)) ? t.pop() : void 0 }(t), { args: n, keys: r } = function dN(t) { if (1 === t.length) { const e = t[0]; if (aN(e)) return { args: e, keys: null }; if (function fN(t) { return t && "object" == typeof t && lN(t) === uN }(e)) { const n = cN(e); return { args: n.map(r => e[r]), keys: n } } } return { args: t, keys: null } }(t), i = new Pe(o => { const { length: s } = n; if (!s) return void o.complete(); const a = new Array(s); let l = s, u = s; for (let c = 0; c < s; c++) { let d = !1; _n(n[c]).subscribe(Yt(o, f => { d || (d = !0, u--), a[c] = f }, () => l--, void 0, () => { (!l || !d) && (u || o.next(r ? mN(r, a) : a), o.complete()) })) } }); return e ? i.pipe(hv(e)) : i } let pv = (() => { class t { constructor(n, r) { this._renderer = n, this._elementRef = r, this.onChange = i => { }, this.onTouched = () => { } } setProperty(n, r) { this._renderer.setProperty(this._elementRef.nativeElement, n, r) } registerOnTouched(n) { this.onTouched = n } registerOnChange(n) { this.onChange = n } setDisabledState(n) { this.setProperty("disabled", n) } } return t.\u0275fac = function (n) { return new (n || t)(v(cr), v(Ve)) }, t.\u0275dir = N({ type: t }), t })(), hr = (() => { class t extends pv { } return t.\u0275fac = function () { let e; return function (r) { return (e || (e = function He(t) { return kn(() => { const e = t.prototype.constructor, n = e[bn] || Ul(e), r = Object.prototype; let i = Object.getPrototypeOf(t.prototype).constructor; for (; i && i !== r;) { const o = i[bn] || Ul(i); if (o && o !== n) return o; i = Object.getPrototypeOf(i) } return o => new o }) }(t)))(r || t) } }(), t.\u0275dir = N({ type: t, features: [Y] }), t })(); const mn = new I("NgValueAccessor"), _N = { provide: mn, useExisting: se(() => pa), multi: !0 }, bN = new I("CompositionEventMode"); let pa = (() => { class t extends pv { constructor(n, r, i) { super(n, r), this._compositionMode = i, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function vN() { const t = fr() ? fr().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(n) { this.setProperty("value", n ?? "") } _handleInput(n) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(n) } _compositionStart() { this._composing = !0 } _compositionEnd(n) { this._composing = !1, this._compositionMode && this.onChange(n) } } return t.\u0275fac = function (n) { return new (n || t)(v(cr), v(Ve), v(bN, 8)) }, t.\u0275dir = N({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (n, r) { 1 & n && Ge("input", function (o) { return r._handleInput(o.target.value) })("blur", function () { return r.onTouched() })("compositionstart", function () { return r._compositionStart() })("compositionend", function (o) { return r._compositionEnd(o.target.value) }) }, features: [le([_N]), Y] }), t })(); function Un(t) { return null == t || ("string" == typeof t || Array.isArray(t)) && 0 === t.length } function gv(t) { return null != t && "number" == typeof t.length } const ze = new I("NgValidators"), Gn = new I("NgAsyncValidators"), DN = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class EN { static min(e) { return function yv(t) { return e => { if (Un(e.value) || Un(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } }(e) } static max(e) { return function _v(t) { return e => { if (Un(e.value) || Un(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } }(e) } static required(e) { return function vv(t) { return Un(t.value) ? { required: !0 } : null }(e) } static requiredTrue(e) { return function bv(t) { return !0 === t.value ? null : { required: !0 } }(e) } static email(e) { return function Dv(t) { return Un(t.value) || DN.test(t.value) ? null : { email: !0 } }(e) } static minLength(e) { return function Ev(t) { return e => Un(e.value) || !gv(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null }(e) } static maxLength(e) { return function wv(t) { return e => gv(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null }(e) } static pattern(e) { return function Cv(t) { if (!t) return ma; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), r => { if (Un(r.value)) return null; const i = r.value; return e.test(i) ? null : { pattern: { requiredPattern: n, actualValue: i } } } }(e) } static nullValidator(e) { return null } static compose(e) { return Fv(e) } static composeAsync(e) { return xv(e) } } function ma(t) { return null } function Mv(t) { return null != t } function Av(t) { const e = ks(t) ? vi(t) : t; return ng(e), e } function Tv(t) { let e = {}; return t.forEach(n => { e = null != n ? { ...e, ...n } : e }), 0 === Object.keys(e).length ? null : e } function Iv(t, e) { return e.map(n => n(t)) } function Sv(t) { return t.map(e => function wN(t) { return !t.validate }(e) ? e : n => e.validate(n)) } function Fv(t) { if (!t) return null; const e = t.filter(Mv); return 0 == e.length ? null : function (n) { return Tv(Iv(n, e)) } } function md(t) { return null != t ? Fv(Sv(t)) : null } function xv(t) { if (!t) return null; const e = t.filter(Mv); return 0 == e.length ? null : function (n) { return gN(Iv(n, e).map(Av)).pipe(il(Tv)) } } function gd(t) { return null != t ? xv(Sv(t)) : null } function Nv(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function kv(t) { return t._rawValidators } function Ov(t) { return t._rawAsyncValidators } function yd(t) { return t ? Array.isArray(t) ? t : [t] : [] } function ga(t, e) { return Array.isArray(t) ? t.includes(e) : t === e } function Pv(t, e) { const n = yd(e); return yd(t).forEach(i => { ga(n, i) || n.push(i) }), n } function Rv(t, e) { return yd(e).filter(n => !ga(t, n)) } class Lv { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(e) { this._rawValidators = e || [], this._composedValidatorFn = md(this._rawValidators) } _setAsyncValidators(e) { this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = gd(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(e) { this._onDestroyCallbacks.push(e) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = [] } reset(e) { this.control && this.control.reset(e) } hasError(e, n) { return !!this.control && this.control.hasError(e, n) } getError(e, n) { return this.control ? this.control.getError(e, n) : null } } class tt extends Lv { get formDirective() { return null } get path() { return null } } class Sn extends Lv { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Vv { constructor(e) { this._cd = e } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Bv = (() => { class t extends Vv { constructor(n) { super(n) } } return t.\u0275fac = function (n) { return new (n || t)(v(Sn, 2)) }, t.\u0275dir = N({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (n, r) { 2 & n && zt("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending) }, features: [Y] }), t })(), jv = (() => { class t extends Vv { constructor(n) { super(n) } } return t.\u0275fac = function (n) { return new (n || t)(v(tt, 10)) }, t.\u0275dir = N({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (n, r) { 2 & n && zt("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending)("ng-submitted", r.isSubmitted) }, features: [Y] }), t })(); const yo = "VALID", _a = "INVALID", fi = "PENDING", _o = "DISABLED"; function Dd(t) { return (va(t) ? t.validators : t) || null } function $v(t) { return Array.isArray(t) ? md(t) : t || null } function Ed(t, e) { return (va(e) ? e.asyncValidators : t) || null } function Uv(t) { return Array.isArray(t) ? gd(t) : t || null } function va(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class qv { constructor(e, n) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = e, this._rawAsyncValidators = n, this._composedValidatorFn = $v(this._rawValidators), this._composedAsyncValidatorFn = Uv(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(e) { this._rawValidators = this._composedValidatorFn = e } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(e) { this._rawAsyncValidators = this._composedAsyncValidatorFn = e } get parent() { return this._parent } get valid() { return this.status === yo } get invalid() { return this.status === _a } get pending() { return this.status == fi } get disabled() { return this.status === _o } get enabled() { return this.status !== _o } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(e) { this._rawValidators = e, this._composedValidatorFn = $v(e) } setAsyncValidators(e) { this._rawAsyncValidators = e, this._composedAsyncValidatorFn = Uv(e) } addValidators(e) { this.setValidators(Pv(e, this._rawValidators)) } addAsyncValidators(e) { this.setAsyncValidators(Pv(e, this._rawAsyncValidators)) } removeValidators(e) { this.setValidators(Rv(e, this._rawValidators)) } removeAsyncValidators(e) { this.setAsyncValidators(Rv(e, this._rawAsyncValidators)) } hasValidator(e) { return ga(this._rawValidators, e) } hasAsyncValidator(e) { return ga(this._rawAsyncValidators, e) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(e = {}) { this.touched = !0, this._parent && !e.onlySelf && this._parent.markAsTouched(e) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(e => e.markAllAsTouched()) } markAsUntouched(e = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => { n.markAsUntouched({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updateTouched(e) } markAsDirty(e = {}) { this.pristine = !1, this._parent && !e.onlySelf && this._parent.markAsDirty(e) } markAsPristine(e = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => { n.markAsPristine({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updatePristine(e) } markAsPending(e = {}) { this.status = fi, !1 !== e.emitEvent && this.statusChanges.emit(this.status), this._parent && !e.onlySelf && this._parent.markAsPending(e) } disable(e = {}) { const n = this._parentMarkedDirty(e.onlySelf); this.status = _o, this.errors = null, this._forEachChild(r => { r.disable({ ...e, onlySelf: !0 }) }), this._updateValue(), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...e, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!0)) } enable(e = {}) { const n = this._parentMarkedDirty(e.onlySelf); this.status = yo, this._forEachChild(r => { r.enable({ ...e, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }), this._updateAncestors({ ...e, skipPristineCheck: n }), this._onDisabledChange.forEach(r => r(!1)) } _updateAncestors(e) { this._parent && !e.onlySelf && (this._parent.updateValueAndValidity(e), e.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(e) { this._parent = e } getRawValue() { return this.value } updateValueAndValidity(e = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === yo || this.status === fi) && this._runAsyncValidator(e.emitEvent)), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !e.onlySelf && this._parent.updateValueAndValidity(e) } _updateTreeValidity(e = { emitEvent: !0 }) { this._forEachChild(n => n._updateTreeValidity(e)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? _o : yo } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(e) { if (this.asyncValidator) { this.status = fi, this._hasOwnPendingAsyncValidator = !0; const n = Av(this.asyncValidator(this)); this._asyncValidationSubscription = n.subscribe(r => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, { emitEvent: e }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(e, n = {}) { this.errors = e, this._updateControlsErrors(!1 !== n.emitEvent) } get(e) { let n = e; return null == n || (Array.isArray(n) || (n = n.split(".")), 0 === n.length) ? null : n.reduce((r, i) => r && r._find(i), this) } getError(e, n) { const r = n ? this.get(n) : this; return r && r.errors ? r.errors[e] : null } hasError(e, n) { return !!this.getError(e, n) } get root() { let e = this; for (; e._parent;)e = e._parent; return e } _updateControlsErrors(e) { this.status = this._calculateStatus(), e && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(e) } _initObservables() { this.valueChanges = new ke, this.statusChanges = new ke } _calculateStatus() { return this._allControlsDisabled() ? _o : this.errors ? _a : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(fi) ? fi : this._anyControlsHaveStatus(_a) ? _a : yo } _anyControlsHaveStatus(e) { return this._anyControls(n => n.status === e) } _anyControlsDirty() { return this._anyControls(e => e.dirty) } _anyControlsTouched() { return this._anyControls(e => e.touched) } _updatePristine(e = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !e.onlySelf && this._parent._updatePristine(e) } _updateTouched(e = {}) { this.touched = this._anyControlsTouched(), this._parent && !e.onlySelf && this._parent._updateTouched(e) } _registerOnCollectionChange(e) { this._onCollectionChange = e } _setUpdateStrategy(e) { va(e) && null != e.updateOn && (this._updateOn = e.updateOn) } _parentMarkedDirty(e) { return !e && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(e) { return null } } class ba extends qv { constructor(e, n, r) { super(Dd(n), Ed(r, n)), this.controls = e, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(e, n) { return this.controls[e] ? this.controls[e] : (this.controls[e] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n) } addControl(e, n, r = {}) { this.registerControl(e, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } removeControl(e, n = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } setControl(e, n, r = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], n && this.registerControl(e, n), this.updateValueAndValidity({ emitEvent: r.emitEvent }), this._onCollectionChange() } contains(e) { return this.controls.hasOwnProperty(e) && this.controls[e].enabled } setValue(e, n = {}) { (function zv(t, e, n) { t._forEachChild((r, i) => { if (void 0 === n[i]) throw new w(1002, "") }) })(this, 0, e), Object.keys(e).forEach(r => { (function Gv(t, e, n) { const r = t.controls; if (!(e ? Object.keys(r) : r).length) throw new w(1e3, ""); if (!r[n]) throw new w(1001, "") })(this, !0, r), this.controls[r].setValue(e[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n) } patchValue(e, n = {}) { null != e && (Object.keys(e).forEach(r => { const i = this.controls[r]; i && i.patchValue(e[r], { onlySelf: !0, emitEvent: n.emitEvent }) }), this.updateValueAndValidity(n)) } reset(e = {}, n = {}) { this._forEachChild((r, i) => { r.reset(e[i], { onlySelf: !0, emitEvent: n.emitEvent }) }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n) } getRawValue() { return this._reduceChildren({}, (e, n, r) => (e[r] = n.getRawValue(), e)) } _syncPendingControls() { let e = this._reduceChildren(!1, (n, r) => !!r._syncPendingControls() || n); return e && this.updateValueAndValidity({ onlySelf: !0 }), e } _forEachChild(e) { Object.keys(this.controls).forEach(n => { const r = this.controls[n]; r && e(r, n) }) } _setUpControls() { this._forEachChild(e => { e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(e) { for (const [n, r] of Object.entries(this.controls)) if (this.contains(n) && e(r)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (n, r, i) => ((r.enabled || this.disabled) && (n[i] = r.value), n)) } _reduceChildren(e, n) { let r = e; return this._forEachChild((i, o) => { r = n(r, i, o) }), r } _allControlsDisabled() { for (const e of Object.keys(this.controls)) if (this.controls[e].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(e) { return this.controls.hasOwnProperty(e) ? this.controls[e] : null } } function vo(t, e) { wd(t, e), e.valueAccessor.writeValue(t.value), t.disabled && e.valueAccessor.setDisabledState?.(!0), function NN(t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && Wv(t, e) }) }(t, e), function ON(t, e) { const n = (r, i) => { e.valueAccessor.writeValue(r), i && e.viewToModelUpdate(r) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function kN(t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && Wv(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function xN(t, e) { if (e.valueAccessor.setDisabledState) { const n = r => { e.valueAccessor.setDisabledState(r) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function Ea(t, e, n = !0) { const r = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(r), e.valueAccessor.registerOnTouched(r)), Ca(t, e), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function wa(t, e) { t.forEach(n => { n.registerOnValidatorChange && n.registerOnValidatorChange(e) }) } function wd(t, e) { const n = kv(t); null !== e.validator ? t.setValidators(Nv(n, e.validator)) : "function" == typeof n && t.setValidators([n]); const r = Ov(t); null !== e.asyncValidator ? t.setAsyncValidators(Nv(r, e.asyncValidator)) : "function" == typeof r && t.setAsyncValidators([r]); const i = () => t.updateValueAndValidity(); wa(e._rawValidators, i), wa(e._rawAsyncValidators, i) } function Ca(t, e) { let n = !1; if (null !== t) { if (null !== e.validator) { const i = kv(t); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== e.validator); o.length !== i.length && (n = !0, t.setValidators(o)) } } if (null !== e.asyncValidator) { const i = Ov(t); if (Array.isArray(i) && i.length > 0) { const o = i.filter(s => s !== e.asyncValidator); o.length !== i.length && (n = !0, t.setAsyncValidators(o)) } } } const r = () => { }; return wa(e._rawValidators, r), wa(e._rawAsyncValidators, r), n } function Wv(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function Kv(t, e) { wd(t, e) } function Zv(t, e) { t._syncPendingControls(), e.forEach(n => { const r = n.control; "submit" === r.updateOn && r._pendingChange && (n.viewToModelUpdate(r._pendingValue), r._pendingChange = !1) }) } const BN = { provide: tt, useExisting: se(() => Ma) }, bo = (() => Promise.resolve(null))(); let Ma = (() => { class t extends tt { constructor(n, r) { super(), this.submitted = !1, this._directives = new Set, this.ngSubmit = new ke, this.form = new ba({}, md(n), gd(r)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(n) { bo.then(() => { const r = this._findContainer(n.path); n.control = r.registerControl(n.name, n.control), vo(n.control, n), n.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(n) }) } getControl(n) { return this.form.get(n.path) } removeControl(n) { bo.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name), this._directives.delete(n) }) } addFormGroup(n) { bo.then(() => { const r = this._findContainer(n.path), i = new ba({}); Kv(i, n), r.registerControl(n.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(n) { bo.then(() => { const r = this._findContainer(n.path); r && r.removeControl(n.name) }) } getFormGroup(n) { return this.form.get(n.path) } updateModel(n, r) { bo.then(() => { this.form.get(n.path).setValue(r) }) } setValue(n) { this.control.setValue(n) } onSubmit(n) { return this.submitted = !0, Zv(this.form, this._directives), this.ngSubmit.emit(n), !1 } onReset() { this.resetForm() } resetForm(n) { this.form.reset(n), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(n) { return n.pop(), n.length ? this.form.get(n) : this.form } } return t.\u0275fac = function (n) { return new (n || t)(v(ze, 10), v(Gn, 10)) }, t.\u0275dir = N({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (n, r) { 1 & n && Ge("submit", function (o) { return r.onSubmit(o) })("reset", function () { return r.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [le([BN]), Y] }), t })(); function Yv(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } function Xv(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } const Do = class extends qv { constructor(e = null, n, r) { super(Dd(n), Ed(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(e), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), va(n) && (n.nonNullable || n.initialValueIsDefault) && (this.defaultValue = Xv(e) ? e.value : e) } setValue(e, n = {}) { this.value = this._pendingValue = e, this._onChange.length && !1 !== n.emitModelToViewChange && this._onChange.forEach(r => r(this.value, !1 !== n.emitViewToModelChange)), this.updateValueAndValidity(n) } patchValue(e, n = {}) { this.setValue(e, n) } reset(e = this.defaultValue, n = {}) { this._applyFormState(e), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1 } _updateValue() { } _anyControls(e) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(e) { this._onChange.push(e) } _unregisterOnChange(e) { Yv(this._onChange, e) } registerOnDisabledChange(e) { this._onDisabledChange.push(e) } _unregisterOnDisabledChange(e) { Yv(this._onDisabledChange, e) } _forEachChild(e) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(e) { Xv(e) ? (this.value = this._pendingValue = e.value, e.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = e } }; let rb = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = N({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), ob = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({}), t })(); const Ad = new I("NgModelWithFormControlWarning"), KN = { provide: tt, useExisting: se(() => Eo) }; let Eo = (() => { class t extends tt { constructor(n, r) { super(), this.validators = n, this.asyncValidators = r, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new ke, this._setValidators(n), this._setAsyncValidators(r) } ngOnChanges(n) { this._checkFormPresent(), n.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Ca(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(n) { const r = this.form.get(n.path); return vo(r, n), r.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(n), r } getControl(n) { return this.form.get(n.path) } removeControl(n) { Ea(n.control || null, n, !1), function VN(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }(this.directives, n) } addFormGroup(n) { this._setUpFormContainer(n) } removeFormGroup(n) { this._cleanUpFormContainer(n) } getFormGroup(n) { return this.form.get(n.path) } addFormArray(n) { this._setUpFormContainer(n) } removeFormArray(n) { this._cleanUpFormContainer(n) } getFormArray(n) { return this.form.get(n.path) } updateModel(n, r) { this.form.get(n.path).setValue(r) } onSubmit(n) { return this.submitted = !0, Zv(this.form, this.directives), this.ngSubmit.emit(n), !1 } onReset() { this.resetForm() } resetForm(n) { this.form.reset(n), this.submitted = !1 } _updateDomValue() { this.directives.forEach(n => { const r = n.control, i = this.form.get(n.path); r !== i && (Ea(r || null, n), (t => t instanceof Do)(i) && (vo(i, n), n.control = i)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(n) { const r = this.form.get(n.path); Kv(r, n), r.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(n) { if (this.form) { const r = this.form.get(n.path); r && function PN(t, e) { return Ca(t, e) }(r, n) && r.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { wd(this.form, this), this._oldForm && Ca(this._oldForm, this) } _checkFormPresent() { } } return t.\u0275fac = function (n) { return new (n || t)(v(ze, 10), v(Gn, 10)) }, t.\u0275dir = N({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (n, r) { 1 & n && Ge("submit", function (o) { return r.onSubmit(o) })("reset", function () { return r.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [le([KN]), Y, Jt] }), t })(); const YN = { provide: Sn, useExisting: se(() => Sd) }; let Sd = (() => { class t extends Sn { constructor(n, r, i, o, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.update = new ke, this._ngModelWarningSent = !1, this._parent = n, this._setValidators(r), this._setAsyncValidators(i), this.valueAccessor = function Md(t, e) { if (!e) return null; let n, r, i; return Array.isArray(e), e.forEach(o => { o.constructor === pa ? n = o : function LN(t) { return Object.getPrototypeOf(t.constructor) === hr }(o) ? r = o : i = o }), i || r || n || null }(0, o) } set isDisabled(n) { } ngOnChanges(n) { this._added || this._setUpControl(), function Cd(t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(n, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(n) { this.viewModel = n, this.update.emit(n) } get path() { return function Da(t, e) { return [...e.path, t] }(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } } return t._ngModelWarningSentOnce = !1, t.\u0275fac = function (n) { return new (n || t)(v(tt, 13), v(ze, 10), v(Gn, 10), v(mn, 10), v(Ad, 8)) }, t.\u0275dir = N({ type: t, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [le([YN]), Y, Jt] }), t })(), h1 = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [ob] }), t })(), p1 = (() => { class t { static withConfig(n) { return { ngModule: t, providers: [{ provide: Ad, useValue: n.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [h1] }), t })(); function mr(t) { return null != t && "false" != `${t}` } function zn(t) { return t instanceof Ve ? t.nativeElement : t } class v1 extends kt { constructor(e, n) { super() } schedule(e, n = 0) { return this } } const Aa = { setInterval(t, e, ...n) { const { delegate: r } = Aa; return r?.setInterval ? r.setInterval(t, e, ...n) : setInterval(t, e, ...n) }, clearInterval(t) { const { delegate: e } = Aa; return (e?.clearInterval || clearInterval)(t) }, delegate: void 0 }, Db = { now: () => (Db.delegate || Date).now(), delegate: void 0 }; class wo { constructor(e, n = wo.now) { this.schedulerActionCtor = e, this.now = n } schedule(e, n = 0, r) { return new this.schedulerActionCtor(this, e).schedule(r, n) } } wo.now = Db.now; const E1 = new class D1 extends wo { constructor(e, n = wo.now) { super(e, n), this.actions = [], this._active = !1, this._scheduled = void 0 } flush(e) { const { actions: n } = this; if (this._active) return void n.push(e); let r; this._active = !0; do { if (r = e.execute(e.state, e.delay)) break } while (e = n.shift()); if (this._active = !1, r) { for (; e = n.shift();)e.unsubscribe(); throw r } } }(class b1 extends v1 { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n, this.pending = !1 } schedule(e, n = 0) { if (this.closed) return this; this.state = e; const r = this.id, i = this.scheduler; return null != r && (this.id = this.recycleAsyncId(i, r, n)), this.pending = !0, this.delay = n, this.id = this.id || this.requestAsyncId(i, this.id, n), this } requestAsyncId(e, n, r = 0) { return Aa.setInterval(e.flush.bind(e, this), r) } recycleAsyncId(e, n, r = 0) { if (null != r && this.delay === r && !1 === this.pending) return n; Aa.clearInterval(n) } execute(e, n) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const r = this._execute(e, n); if (r) return r; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(e, n) { let i, r = !1; try { this.work(e) } catch (o) { r = !0, i = o || new Error("Scheduled action threw falsy error") } if (r) return this.unsubscribe(), i } unsubscribe() { if (!this.closed) { const { id: e, scheduler: n } = this, { actions: r } = n; this.work = this.state = this.scheduler = null, this.pending = !1, wr(r, this), null != e && (this.id = this.recycleAsyncId(n, e, null)), this.delay = null, super.unsubscribe() } } }); let kd, Eb = (() => { class t { create(n) { return typeof MutationObserver > "u" ? null : new MutationObserver(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), C1 = (() => { class t { constructor(n) { this._mutationObserverFactory = n, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((n, r) => this._cleanupObserver(r)) } observe(n) { const r = zn(n); return new Pe(i => { const s = this._observeElement(r).subscribe(i); return () => { s.unsubscribe(), this._unobserveElement(r) } }) } _observeElement(n) { if (this._observedElements.has(n)) this._observedElements.get(n).count++; else { const r = new Ot, i = this._mutationObserverFactory.create(o => r.next(o)); i && i.observe(n, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(n, { observer: i, stream: r, count: 1 }) } return this._observedElements.get(n).stream } _unobserveElement(n) { this._observedElements.has(n) && (this._observedElements.get(n).count--, this._observedElements.get(n).count || this._cleanupObserver(n)) } _cleanupObserver(n) { if (this._observedElements.has(n)) { const { observer: r, stream: i } = this._observedElements.get(n); r && r.disconnect(), i.complete(), this._observedElements.delete(n) } } } return t.\u0275fac = function (n) { return new (n || t)(S(Eb)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), M1 = (() => { class t { constructor(n, r, i) { this._contentObserver = n, this._elementRef = r, this._ngZone = i, this.event = new ke, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(n) { this._disabled = mr(n), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(n) { this._debounce = function y1(t, e = 0) { return function _1(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e }(n), this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const n = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? n.pipe(function w1(t, e = E1) { return Pt((n, r) => { let i = null, o = null, s = null; const a = () => { if (i) { i.unsubscribe(), i = null; const u = o; o = null, r.next(u) } }; function l() { const u = s + t, c = e.now(); if (c < u) return i = this.schedule(void 0, u - c), void r.add(i); a() } n.subscribe(Yt(r, u => { o = u, s = e.now(), i || (i = e.schedule(l, t), r.add(i)) }, () => { a(), r.complete() }, void 0, () => { o = i = null })) }) }(this.debounce)) : n).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription?.unsubscribe() } } return t.\u0275fac = function (n) { return new (n || t)(v(C1), v(Ve), v(ue)) }, t.\u0275dir = N({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), A1 = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ providers: [Eb] }), t })(); try { kd = typeof Intl < "u" && Intl.v8BreakIterator } catch { kd = !1 } let hi, gr = (() => { class t { constructor(n) { this._platformId = n, this.isBrowser = this._platformId ? function Cx(t) { return t === W_ }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !kd) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (n) { return new (n || t)(S(Lc)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const wb = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function Cb() { if (hi) return hi; if ("object" != typeof document || !document) return hi = new Set(wb), hi; let t = document.createElement("input"); return hi = new Set(wb.filter(e => (t.setAttribute("type", e), t.type === e))), hi } let Co, Od; function Ta(t) { return function T1() { if (null == Co && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Co = !0 })) } finally { Co = Co || !1 } return Co }() ? t : !!t.capture } function Mo(t) { return t.composedPath ? t.composedPath()[0] : t.target } class Mb extends Ot { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const n = super._subscribe(e); return !n.closed && e.next(this._value), n } getValue() { const { hasError: e, thrownError: n, _value: r } = this; if (e) throw n; return this._throwIfClosed(), r } next(e) { super.next(this._value = e) } } function j1(t, e) { return t === e } function Sa(t) { return Pt((e, n) => { _n(t).subscribe(Yt(n, () => n.complete(), Ya)), !n.closed && e.subscribe(n) }) } function Sb(t) { return 0 === t.buttons || 0 === t.offsetX && 0 === t.offsetY } function Fb(t) { const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY) } const K1 = new I("cdk-input-modality-detector-options"), Q1 = { ignoreKeys: [18, 17, 224, 91, 16] }, pi = Ta({ passive: !0, capture: !0 }); let Z1 = (() => { class t { constructor(n, r, i, o) { this._platform = n, this._mostRecentTarget = null, this._modality = new Mb(null), this._lastTouchMs = 0, this._onKeydown = s => { this._options?.ignoreKeys?.some(a => a === s.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = Mo(s)) }, this._onMousedown = s => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(Sb(s) ? "keyboard" : "mouse"), this._mostRecentTarget = Mo(s)) }, this._onTouchstart = s => { Fb(s) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Mo(s)) }, this._options = { ...Q1, ...o }, this.modalityDetected = this._modality.pipe(function V1(t) { return function L1(t, e) { return Pt((n, r) => { let i = 0; n.subscribe(Yt(r, o => t.call(e, o, i++) && r.next(o))) }) }((e, n) => t <= n) }(1)), this.modalityChanged = this.modalityDetected.pipe(function B1(t, e = rl) { return t = t ?? j1, Pt((n, r) => { let i, o = !0; n.subscribe(Yt(r, s => { const a = e(s); (o || !t(i, a)) && (o = !1, i = a, r.next(s)) })) }) }()), n.isBrowser && r.runOutsideAngular(() => { i.addEventListener("keydown", this._onKeydown, pi), i.addEventListener("mousedown", this._onMousedown, pi), i.addEventListener("touchstart", this._onTouchstart, pi) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, pi), document.removeEventListener("mousedown", this._onMousedown, pi), document.removeEventListener("touchstart", this._onTouchstart, pi)) } } return t.\u0275fac = function (n) { return new (n || t)(S(gr), S(ue), S(Be), S(K1, 8)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const X1 = new I("cdk-focus-monitor-default-options"), Fa = Ta({ passive: !0, capture: !0 }); let J1 = (() => { class t { constructor(n, r, i, o, s) { this._ngZone = n, this._platform = r, this._inputModalityDetector = i, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new Ot, this._rootNodeFocusAndBlurListener = a => { const l = Mo(a), u = "focus" === a.type ? this._onFocus : this._onBlur; for (let c = l; c; c = c.parentElement)u.call(this, a, c) }, this._document = o, this._detectionMode = s?.detectionMode || 0 } monitor(n, r = !1) { const i = zn(n); if (!this._platform.isBrowser || 1 !== i.nodeType) return function x1(...t) { return vi(t, Vo(t)) }(null); const o = function S1(t) { if (function I1() { if (null == Od) { const t = typeof document < "u" ? document.head : null; Od = !(!t || !t.createShadowRoot && !t.attachShadow) } return Od }()) { const e = t.getRootNode ? t.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && e instanceof ShadowRoot) return e } return null }(i) || this._getDocument(), s = this._elementInfo.get(i); if (s) return r && (s.checkChildren = !0), s.subject; const a = { checkChildren: r, subject: new Ot, rootNode: o }; return this._elementInfo.set(i, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(n) { const r = zn(n), i = this._elementInfo.get(r); i && (i.subject.complete(), this._setClasses(r), this._elementInfo.delete(r), this._removeGlobalListeners(i)) } focusVia(n, r, i) { const o = zn(n); o === this._getDocument().activeElement ? this._getClosestElementsInfo(o).forEach(([a, l]) => this._originChanged(a, r, l)) : (this._setOrigin(r), "function" == typeof o.focus && o.focus(i)) } ngOnDestroy() { this._elementInfo.forEach((n, r) => this.stopMonitoring(r)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(n) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(n) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(n) { return 1 === this._detectionMode || !!n?.contains(this._inputModalityDetector._mostRecentTarget) } _setClasses(n, r) { n.classList.toggle("cdk-focused", !!r), n.classList.toggle("cdk-touch-focused", "touch" === r), n.classList.toggle("cdk-keyboard-focused", "keyboard" === r), n.classList.toggle("cdk-mouse-focused", "mouse" === r), n.classList.toggle("cdk-program-focused", "program" === r) } _setOrigin(n, r = !1) { this._ngZone.runOutsideAngular(() => { this._origin = n, this._originFromTouchInteraction = "touch" === n && r, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(n, r) { const i = this._elementInfo.get(r), o = Mo(n); !i || !i.checkChildren && r !== o || this._originChanged(r, this._getFocusOrigin(o), i) } _onBlur(n, r) { const i = this._elementInfo.get(r); !i || i.checkChildren && n.relatedTarget instanceof Node && r.contains(n.relatedTarget) || (this._setClasses(r), this._emitOrigin(i, null)) } _emitOrigin(n, r) { n.subject.observers.length && this._ngZone.run(() => n.subject.next(r)) } _registerGlobalListeners(n) { if (!this._platform.isBrowser) return; const r = n.rootNode, i = this._rootNodeFocusListenerCount.get(r) || 0; i || this._ngZone.runOutsideAngular(() => { r.addEventListener("focus", this._rootNodeFocusAndBlurListener, Fa), r.addEventListener("blur", this._rootNodeFocusAndBlurListener, Fa) }), this._rootNodeFocusListenerCount.set(r, i + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(Sa(this._stopInputModalityDetector)).subscribe(o => { this._setOrigin(o, !0) })) } _removeGlobalListeners(n) { const r = n.rootNode; if (this._rootNodeFocusListenerCount.has(r)) { const i = this._rootNodeFocusListenerCount.get(r); i > 1 ? this._rootNodeFocusListenerCount.set(r, i - 1) : (r.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Fa), r.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Fa), this._rootNodeFocusListenerCount.delete(r)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(n, r, i) { this._setClasses(n, r), this._emitOrigin(i, r), this._lastFocusOrigin = r } _getClosestElementsInfo(n) { const r = []; return this._elementInfo.forEach((i, o) => { (o === n || i.checkChildren && o.contains(n)) && r.push([o, i]) }), r } } return t.\u0275fac = function (n) { return new (n || t)(S(ue), S(gr), S(Z1), S(Be, 8), S(X1, 8)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const Nb = "cdk-high-contrast-black-on-white", kb = "cdk-high-contrast-white-on-black", Pd = "cdk-high-contrast-active"; let ek = (() => { class t { constructor(n, r) { this._platform = n, this._document = r } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const n = this._document.createElement("div"); n.style.backgroundColor = "rgb(1,2,3)", n.style.position = "absolute", this._document.body.appendChild(n); const r = this._document.defaultView || window, i = r && r.getComputedStyle ? r.getComputedStyle(n) : null, o = (i && i.backgroundColor || "").replace(/ /g, ""); switch (n.remove(), o) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const n = this._document.body.classList; n.remove(Pd, Nb, kb), this._hasCheckedHighContrastMode = !0; const r = this.getHighContrastMode(); 1 === r ? n.add(Pd, Nb) : 2 === r && n.add(Pd, kb) } } } return t.\u0275fac = function (n) { return new (n || t)(S(gr), S(Be)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); const tk = new I("cdk-dir-doc", { providedIn: "root", factory: function nk() { return Zl(Be) } }), rk = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let ok = (() => { class t { constructor(n) { if (this.value = "ltr", this.change = new ke, n) { const i = n.documentElement ? n.documentElement.dir : null; this.value = function ik(t) { const e = t?.toLowerCase() || ""; return "auto" === e && typeof navigator < "u" && navigator?.language ? rk.test(navigator.language) ? "rtl" : "ltr" : "rtl" === e ? "rtl" : "ltr" }((n.body ? n.body.dir : null) || i || "ltr") } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (n) { return new (n || t)(S(tk, 8)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Ob = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({}), t })(); const ak = new I("mat-sanity-checks", { providedIn: "root", factory: function sk() { return !0 } }); let _r = (() => { class t { constructor(n, r, i) { this._sanityChecks = r, this._document = i, this._hasDoneGlobalChecks = !1, n._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(n) { return !function F1() { return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha }() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[n]) } } return t.\u0275fac = function (n) { return new (n || t)(S(ek), S(ak, 8), S(Be)) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [Ob, Ob] }), t })(); function lk(t) { return class extends t { constructor(...e) { super(...e), this._disabled = !1 } get disabled() { return this._disabled } set disabled(e) { this._disabled = mr(e) } } } function Lb(t, e) { return class extends t { constructor(...n) { super(...n), this.defaultColor = e, this.color = e } get color() { return this._color } set color(n) { const r = n || this.defaultColor; r !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), r && this._elementRef.nativeElement.classList.add(`mat-${r}`), this._color = r) } } } function uk(t) { return class extends t { constructor(...e) { super(...e), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(e) { this._disableRipple = mr(e) } } } function ck(t) { return class extends t { constructor(...e) { super(...e), this.errorState = !1 } updateErrorState() { const e = this.errorState, o = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); o !== e && (this.errorState = o, this.stateChanges.next()) } } } let Vb = (() => { class t { isErrorState(n, r) { return !!(n && n.invalid && (n.touched || r && r.submitted)) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class fk { constructor(e, n, r, i = !1) { this._renderer = e, this.element = n, this.config = r, this._animationForciblyDisabledThroughCss = i, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const Bb = { enterDuration: 225, exitDuration: 150 }, Rd = Ta({ passive: !0 }), jb = ["mousedown", "touchstart"], Hb = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class pk { constructor(e, n, r, i) { this._target = e, this._ngZone = n, this._isPointerDown = !1, this._activeRipples = new Map, this._pointerUpEventsRegistered = !1, i.isBrowser && (this._containerElement = zn(r)) } fadeInRipple(e, n, r = {}) { const i = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), o = { ...Bb, ...r.animation }; r.centered && (e = i.left + i.width / 2, n = i.top + i.height / 2); const s = r.radius || function mk(t, e, n) { const r = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), i = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(r * r + i * i) }(e, n, i), a = e - i.left, l = n - i.top, u = o.enterDuration, c = document.createElement("div"); c.classList.add("mat-ripple-element"), c.style.left = a - s + "px", c.style.top = l - s + "px", c.style.height = 2 * s + "px", c.style.width = 2 * s + "px", null != r.color && (c.style.backgroundColor = r.color), c.style.transitionDuration = `${u}ms`, this._containerElement.appendChild(c); const d = window.getComputedStyle(c), h = d.transitionDuration, p = "none" === d.transitionProperty || "0s" === h || "0s, 0s" === h, m = new fk(this, c, r, p); c.style.transform = "scale3d(1, 1, 1)", m.state = 0, r.persistent || (this._mostRecentTransientRipple = m); let y = null; return !p && (u || o.exitDuration) && this._ngZone.runOutsideAngular(() => { const _ = () => this._finishRippleTransition(m), D = () => this._destroyRipple(m); c.addEventListener("transitionend", _), c.addEventListener("transitioncancel", D), y = { onTransitionEnd: _, onTransitionCancel: D } }), this._activeRipples.set(m, y), (p || !u) && this._finishRippleTransition(m), m } fadeOutRipple(e) { if (2 === e.state || 3 === e.state) return; const n = e.element, r = { ...Bb, ...e.config.animation }; n.style.transitionDuration = `${r.exitDuration}ms`, n.style.opacity = "0", e.state = 2, (e._animationForciblyDisabledThroughCss || !r.exitDuration) && this._finishRippleTransition(e) } fadeOutAll() { this._getActiveRipples().forEach(e => e.fadeOut()) } fadeOutAllNonPersistent() { this._getActiveRipples().forEach(e => { e.config.persistent || e.fadeOut() }) } setupTriggerEvents(e) { const n = zn(e); !n || n === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = n, this._registerEvents(jb)) } handleEvent(e) { "mousedown" === e.type ? this._onMousedown(e) : "touchstart" === e.type ? this._onTouchStart(e) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(Hb), this._pointerUpEventsRegistered = !0) } _finishRippleTransition(e) { 0 === e.state ? this._startFadeOutTransition(e) : 2 === e.state && this._destroyRipple(e) } _startFadeOutTransition(e) { const n = e === this._mostRecentTransientRipple, { persistent: r } = e.config; e.state = 1, !r && (!n || !this._isPointerDown) && e.fadeOut() } _destroyRipple(e) { const n = this._activeRipples.get(e) ?? null; this._activeRipples.delete(e), this._activeRipples.size || (this._containerRect = null), e === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), e.state = 3, null !== n && (e.element.removeEventListener("transitionend", n.onTransitionEnd), e.element.removeEventListener("transitioncancel", n.onTransitionCancel)), e.element.remove() } _onMousedown(e) { const n = Sb(e), r = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !n && !r && (this._isPointerDown = !0, this.fadeInRipple(e.clientX, e.clientY, this._target.rippleConfig)) } _onTouchStart(e) { if (!this._target.rippleDisabled && !Fb(e)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const n = e.changedTouches; for (let r = 0; r < n.length; r++)this.fadeInRipple(n[r].clientX, n[r].clientY, this._target.rippleConfig) } } _onPointerUp() { !this._isPointerDown || (this._isPointerDown = !1, this._getActiveRipples().forEach(e => { !e.config.persistent && (1 === e.state || e.config.terminateOnPointerUp && 0 === e.state) && e.fadeOut() })) } _registerEvents(e) { this._ngZone.runOutsideAngular(() => { e.forEach(n => { this._triggerElement.addEventListener(n, this, Rd) }) }) } _getActiveRipples() { return Array.from(this._activeRipples.keys()) } _removeTriggerEvents() { this._triggerElement && (jb.forEach(e => { this._triggerElement.removeEventListener(e, this, Rd) }), this._pointerUpEventsRegistered && Hb.forEach(e => { this._triggerElement.removeEventListener(e, this, Rd) })) } } const gk = new I("mat-ripple-global-options"); let $b = (() => { class t { constructor(n, r, i, o, s) { this._elementRef = n, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = o || {}, this._rippleRenderer = new pk(this, r, n, i) } get disabled() { return this._disabled } set disabled(n) { n && this.fadeOutAllNonPersistent(), this._disabled = n, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(n) { this._trigger = n, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: { ...this._globalOptions.animation, ..."NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}, ...this.animation }, terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(n, r = 0, i) { return "number" == typeof n ? this._rippleRenderer.fadeInRipple(n, r, { ...this.rippleConfig, ...i }) : this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...n }) } } return t.\u0275fac = function (n) { return new (n || t)(v(Ve), v(ue), v(gr), v(gk, 8), v(co, 8)) }, t.\u0275dir = N({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (n, r) { 2 & n && zt("mat-ripple-unbounded", r.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }), t })(), yk = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [_r, _r] }), t })(); const _k = ["addListener", "removeListener"], vk = ["addEventListener", "removeEventListener"], bk = ["on", "off"]; function Ld(t, e, n, r) { if (ee(n) && (r = n, n = void 0), r) return Ld(t, e, n).pipe(hv(r)); const [i, o] = function wk(t) { return ee(t.addEventListener) && ee(t.removeEventListener) }(t) ? vk.map(s => a => t[s](e, a, n)) : function Dk(t) { return ee(t.addListener) && ee(t.removeListener) }(t) ? _k.map(Ub(t, e)) : function Ek(t) { return ee(t.on) && ee(t.off) }(t) ? bk.map(Ub(t, e)) : []; if (!i && sl(t)) return al(s => Ld(s, e, n))(_n(t)); if (!i) throw new TypeError("Invalid event target"); return new Pe(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return i(a), () => o(a) }) } function Ub(t, e) { return n => r => t[n](e, r) } function Gb(...t) { return function Ck() { return Pf(1) }()(vi(t, Vo(t))) } function Vd(...t) { const e = Vo(t); return Pt((n, r) => { (e ? Gb(t, n, e) : Gb(t, n)).subscribe(r) }) } class zb { } const Fn = "*"; function Ak(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function Tk(t, e = null) { return { type: 4, styles: e, timings: t } } function qb(t, e = null) { return { type: 2, steps: t, options: e } } function xa(t) { return { type: 6, styles: t, offset: null } } function Ik(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function Sk(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function Wb(t) { Promise.resolve(null).then(t) } class To { constructor(e = 0, n = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + n } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { Wb(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(e) { this._position = this.totalTime ? e * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class Kb { constructor(e) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e; let n = 0, r = 0, i = 0; const o = this.players.length; 0 == o ? Wb(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++n == o && this._onFinish() }), s.onDestroy(() => { ++r == o && this._onDestroy() }), s.onStart(() => { ++i == o && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this.players.forEach(e => e.init()) } onStart(e) { this._onStartFns.push(e) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = []) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play()) } pause() { this.players.forEach(e => e.pause()) } restart() { this.players.forEach(e => e.restart()) } finish() { this._onFinish(), this.players.forEach(e => e.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(e) { const n = e * this.totalTime; this.players.forEach(r => { const i = r.totalTime ? Math.min(1, n / r.totalTime) : 1; r.setPosition(i) }) } getPosition() { const e = this.players.reduce((n, r) => null === n || r.totalTime > n.totalTime ? r : n, null); return null != e ? e.getPosition() : 0 } beforeDestroy() { this.players.forEach(e => { e.beforeDestroy && e.beforeDestroy() }) } triggerCallback(e) { const n = "start" == e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } const Fk = ["connectionContainer"], xk = ["inputContainer"], Nk = ["label"]; function kk(t, e) { 1 & t && (Qi(0), he(1, "div", 14), sn(2, "div", 15)(3, "div", 16)(4, "div", 17), de(), he(5, "div", 18), sn(6, "div", 15)(7, "div", 16)(8, "div", 17), de(), Zi()) } function Ok(t, e) { if (1 & t) { const n = ac(); he(0, "div", 19), Ge("cdkObserveContent", function () { return Fl(n), xl(an().updateOutlineGap()) }), ln(1, 1), de() } 2 & t && De("cdkObserveContentDisabled", "outline" != an().appearance) } function Pk(t, e) { if (1 & t && (Qi(0), ln(1, 2), he(2, "span"), jn(3), de(), Zi()), 2 & t) { const n = an(2); Le(3), Ps(n._control.placeholder) } } function Rk(t, e) { 1 & t && ln(0, 3, ["*ngSwitchCase", "true"]) } function Lk(t, e) { 1 & t && (he(0, "span", 23), jn(1, " *"), de()) } function Vk(t, e) { if (1 & t) { const n = ac(); he(0, "label", 20, 21), Ge("cdkObserveContent", function () { return Fl(n), xl(an().updateOutlineGap()) }), Tt(2, Pk, 4, 1, "ng-container", 12), Tt(3, Rk, 1, 0, "ng-content", 12), Tt(4, Lk, 2, 0, "span", 22), de() } if (2 & t) { const n = an(); zt("mat-empty", n._control.empty && !n._shouldAlwaysFloat())("mat-form-field-empty", n._control.empty && !n._shouldAlwaysFloat())("mat-accent", "accent" == n.color)("mat-warn", "warn" == n.color), De("cdkObserveContentDisabled", "outline" != n.appearance)("id", n._labelId)("ngSwitch", n._hasLabel()), At("for", n._control.id)("aria-owns", n._control.id), Le(2), De("ngSwitchCase", !1), Le(1), De("ngSwitchCase", !0), Le(1), De("ngIf", !n.hideRequiredMarker && n._control.required && !n._control.disabled) } } function Bk(t, e) { 1 & t && (he(0, "div", 24), ln(1, 4), de()) } function jk(t, e) { if (1 & t && (he(0, "div", 25), sn(1, "span", 26), de()), 2 & t) { const n = an(); Le(1), zt("mat-accent", "accent" == n.color)("mat-warn", "warn" == n.color) } } function Hk(t, e) { 1 & t && (he(0, "div"), ln(1, 5), de()), 2 & t && De("@transitionMessages", an()._subscriptAnimationState) } function $k(t, e) { if (1 & t && (he(0, "div", 30), jn(1), de()), 2 & t) { const n = an(2); De("id", n._hintLabelId), Le(1), Ps(n.hintLabel) } } function Uk(t, e) { if (1 & t && (he(0, "div", 27), Tt(1, $k, 2, 2, "div", 28), ln(2, 6), sn(3, "div", 29), ln(4, 7), de()), 2 & t) { const n = an(); De("@transitionMessages", n._subscriptAnimationState), Le(1), De("ngIf", n.hintLabel) } } const Gk = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], zk = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"], qk = new I("MatError"), Wk = { transitionMessages: Ak("transitionMessages", [Ik("enter", xa({ opacity: 1, transform: "translateY(0%)" })), Sk("void => enter", [xa({ opacity: 0, transform: "translateY(-5px)" }), Tk("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let jd = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = N({ type: t }), t })(); const Kk = new I("MatHint"); let Hd = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = N({ type: t, selectors: [["mat-label"]] }), t })(), Qk = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275dir = N({ type: t, selectors: [["mat-placeholder"]] }), t })(); const Zk = new I("MatPrefix"), Yk = new I("MatSuffix"); let Qb = 0; const Jk = Lb(class { constructor(t) { this._elementRef = t } }, "primary"), eO = new I("MAT_FORM_FIELD_DEFAULT_OPTIONS"), Yb = new I("MatFormField"); let tO = (() => { class t extends Jk { constructor(n, r, i, o, s, a, l) { super(n), this._changeDetectorRef = r, this._dir = i, this._defaults = o, this._platform = s, this._ngZone = a, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new Ot, this._hideRequiredMarker = !1, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + Qb++, this._labelId = "mat-form-field-label-" + Qb++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== l, this.appearance = o?.appearance || "legacy", o && (this._hideRequiredMarker = Boolean(o.hideRequiredMarker), o.color && (this.color = this.defaultColor = o.color)) } get appearance() { return this._appearance } set appearance(n) { const r = this._appearance; this._appearance = n || this._defaults?.appearance || "legacy", "outline" === this._appearance && r !== n && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(n) { this._hideRequiredMarker = mr(n) } _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(n) { this._hintLabel = n, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(n) { n !== this._floatLabel && (this._floatLabel = n || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(n) { this._explicitFormFieldControl = n } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const n = this._control; n.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${n.controlType}`), n.stateChanges.pipe(Vd(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), n.ngControl && n.ngControl.valueChanges && n.ngControl.valueChanges.pipe(Sa(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(Sa(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), Bf(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(Vd(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(Vd(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(Sa(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(n) { const r = this._control ? this._control.ngControl : null; return r && r[n] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !(!this._labelChildNonStatic && !this._labelChildStatic) } _shouldLabelFloat() { return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat()) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Ld(this._label.nativeElement, "transitionend").pipe(jf(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || "auto" } _syncDescribedByIds() { if (this._control) { let n = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && n.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const r = this._hintChildren ? this._hintChildren.find(o => "start" === o.align) : null, i = this._hintChildren ? this._hintChildren.find(o => "end" === o.align) : null; r ? n.push(r.id) : this._hintLabel && n.push(this._hintLabelId), i && n.push(i.id) } else this._errorChildren && n.push(...this._errorChildren.map(r => r.id)); this._control.setDescribedByIds(n) } } _validateControlChild() { } updateOutlineGap() { const n = this._label ? this._label.nativeElement : null, r = this._connectionContainerRef.nativeElement, i = ".mat-form-field-outline-start", o = ".mat-form-field-outline-gap"; if ("outline" !== this.appearance || !this._platform.isBrowser) return; if (!n || !n.children.length || !n.textContent.trim()) { const c = r.querySelectorAll(`${i}, ${o}`); for (let d = 0; d < c.length; d++)c[d].style.width = "0"; return } if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let s = 0, a = 0; const l = r.querySelectorAll(i), u = r.querySelectorAll(o); if (this._label && this._label.nativeElement.children.length) { const c = r.getBoundingClientRect(); if (0 === c.width && 0 === c.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const d = this._getStartEnd(c), f = n.children, h = this._getStartEnd(f[0].getBoundingClientRect()); let p = 0; for (let m = 0; m < f.length; m++)p += f[m].offsetWidth; s = Math.abs(h - d) - 5, a = p > 0 ? .75 * p + 10 : 0 } for (let c = 0; c < l.length; c++)l[c].style.width = `${s}px`; for (let c = 0; c < u.length; c++)u[c].style.width = `${a}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(n) { return this._dir && "rtl" === this._dir.value ? n.right : n.left } _isAttachedToDOM() { const n = this._elementRef.nativeElement; if (n.getRootNode) { const r = n.getRootNode(); return r && r !== n } return document.documentElement.contains(n) } } return t.\u0275fac = function (n) { return new (n || t)(v(Ve), v(Ks), v(ok, 8), v(eO, 8), v(gr), v(ue), v(co, 8)) }, t.\u0275cmp = Di({ type: t, selectors: [["mat-form-field"]], contentQueries: function (n, r, i) { if (1 & n && (fn(i, jd, 5), fn(i, jd, 7), fn(i, Hd, 5), fn(i, Hd, 7), fn(i, Qk, 5), fn(i, qk, 5), fn(i, Kk, 5), fn(i, Zk, 5), fn(i, Yk, 5)), 2 & n) { let o; it(o = ot()) && (r._controlNonStatic = o.first), it(o = ot()) && (r._controlStatic = o.first), it(o = ot()) && (r._labelChildNonStatic = o.first), it(o = ot()) && (r._labelChildStatic = o.first), it(o = ot()) && (r._placeholderChild = o.first), it(o = ot()) && (r._errorChildren = o), it(o = ot()) && (r._hintChildren = o), it(o = ot()) && (r._prefixChildren = o), it(o = ot()) && (r._suffixChildren = o) } }, viewQuery: function (n, r) { if (1 & n && (so(Fk, 7), so(xk, 5), so(Nk, 5)), 2 & n) { let i; it(i = ot()) && (r._connectionContainerRef = i.first), it(i = ot()) && (r._inputContainerRef = i.first), it(i = ot()) && (r._label = i.first) } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function (n, r) { 2 & n && zt("mat-form-field-appearance-standard", "standard" == r.appearance)("mat-form-field-appearance-fill", "fill" == r.appearance)("mat-form-field-appearance-outline", "outline" == r.appearance)("mat-form-field-appearance-legacy", "legacy" == r.appearance)("mat-form-field-invalid", r._control.errorState)("mat-form-field-can-float", r._canLabelFloat())("mat-form-field-should-float", r._shouldLabelFloat())("mat-form-field-has-label", r._hasFloatingLabel())("mat-form-field-hide-placeholder", r._hideControlPlaceholder())("mat-form-field-disabled", r._control.disabled)("mat-form-field-autofilled", r._control.autofilled)("mat-focused", r._control.focused)("ng-untouched", r._shouldForward("untouched"))("ng-touched", r._shouldForward("touched"))("ng-pristine", r._shouldForward("pristine"))("ng-dirty", r._shouldForward("dirty"))("ng-valid", r._shouldForward("valid"))("ng-invalid", r._shouldForward("invalid"))("ng-pending", r._shouldForward("pending"))("_mat-animation-noopable", !r._animationsEnabled) }, inputs: { color: "color", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel", floatLabel: "floatLabel" }, exportAs: ["matFormField"], features: [le([{ provide: Yb, useExisting: t }]), Y], ngContentSelectors: zk, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 3, "cdkObserveContentDisabled", "cdkObserveContent", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix", 3, "cdkObserveContentDisabled", "cdkObserveContent"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (n, r) { 1 & n && (uc(Gk), he(0, "div", 0)(1, "div", 1, 2), Ge("click", function (o) { return r._control.onContainerClick && r._control.onContainerClick(o) }), Tt(3, kk, 9, 0, "ng-container", 3), Tt(4, Ok, 2, 1, "div", 4), he(5, "div", 5, 6), ln(7), he(8, "span", 7), Tt(9, Vk, 5, 16, "label", 8), de()(), Tt(10, Bk, 2, 0, "div", 9), de(), Tt(11, jk, 2, 4, "div", 10), he(12, "div", 11), Tt(13, Hk, 2, 1, "div", 12), Tt(14, Uk, 5, 2, "div", 13), de()()), 2 & n && (Le(3), De("ngIf", "outline" == r.appearance), Le(1), De("ngIf", r._prefixChildren.length), Le(5), De("ngIf", r._hasFloatingLabel()), Le(1), De("ngIf", r._suffixChildren.length), Le(1), De("ngIf", "outline" != r.appearance), Le(1), De("ngSwitch", r._getDisplayedMessages()), Le(1), De("ngSwitchCase", "error"), Le(1), De("ngSwitchCase", "hint")) }, dependencies: [H_, la, U_, M1], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.cdk-high-contrast-active .mat-form-field-disabled .mat-form-field-label{color:GrayText}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}', '.mat-input-element{font:inherit;background:rgba(0,0,0,0);color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element:not([type=password])::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}._mat-animation-noopable .mat-input-element::placeholder{transition:none}._mat-animation-noopable .mat-input-element::-moz-placeholder{transition:none}._mat-animation-noopable .mat-input-element::-webkit-input-placeholder{transition:none}._mat-animation-noopable .mat-input-element:-ms-input-placeholder{transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px)}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px;border-top-color:GrayText}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:rgba(0,0,0,0)}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:GrayText}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:rgba(0,0,0,0)}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}"], encapsulation: 2, data: { animation: [Wk.transitionMessages] }, changeDetection: 0 }), t })(), $d = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [q_, _r, A1, _r] }), t })(); const Xb = Ta({ passive: !0 }); let nO = (() => { class t { constructor(n, r) { this._platform = n, this._ngZone = r, this._monitoredElements = new Map } monitor(n) { if (!this._platform.isBrowser) return Lo; const r = zn(n), i = this._monitoredElements.get(r); if (i) return i.subject; const o = new Ot, s = "cdk-text-field-autofilled", a = l => { "cdk-text-field-autofill-start" !== l.animationName || r.classList.contains(s) ? "cdk-text-field-autofill-end" === l.animationName && r.classList.contains(s) && (r.classList.remove(s), this._ngZone.run(() => o.next({ target: l.target, isAutofilled: !1 }))) : (r.classList.add(s), this._ngZone.run(() => o.next({ target: l.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { r.addEventListener("animationstart", a, Xb), r.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(r, { subject: o, unlisten: () => { r.removeEventListener("animationstart", a, Xb) } }), o } stopMonitoring(n) { const r = zn(n), i = this._monitoredElements.get(r); i && (i.unlisten(), i.subject.complete(), r.classList.remove("cdk-text-field-autofill-monitored"), r.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(r)) } ngOnDestroy() { this._monitoredElements.forEach((n, r) => this.stopMonitoring(r)) } } return t.\u0275fac = function (n) { return new (n || t)(S(gr), S(ue)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Jb = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({}), t })(); const rO = new I("MAT_INPUT_VALUE_ACCESSOR"), iO = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let oO = 0; const sO = ck(class { constructor(t, e, n, r) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = r, this.stateChanges = new Ot } }); let aO = (() => { class t extends sO { constructor(n, r, i, o, s, a, l, u, c, d) { super(a, o, s, i), this._elementRef = n, this._platform = r, this._autofillMonitor = u, this._formField = d, this._uid = "mat-input-" + oO++, this.focused = !1, this.stateChanges = new Ot, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(p => Cb().has(p)), this._iOSKeyupListener = p => { const m = p.target; !m.value && 0 === m.selectionStart && 0 === m.selectionEnd && (m.setSelectionRange(1, 1), m.setSelectionRange(0, 0)) }; const f = this._elementRef.nativeElement, h = f.nodeName.toLowerCase(); this._inputValueAccessor = l || f, this._previousNativeValue = this.value, this.id = this.id, r.IOS && c.runOutsideAngular(() => { n.nativeElement.addEventListener("keyup", this._iOSKeyupListener) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === h, this._isTextarea = "textarea" === h, this._isInFormField = !!d, this._isNativeSelect && (this.controlType = f.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(n) { this._disabled = mr(n), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(n) { this._id = n || this._uid } get required() { return this._required ?? this.ngControl?.control?.hasValidator(EN.required) ?? !1 } set required(n) { this._required = mr(n) } get type() { return this._type } set type(n) { this._type = n || "text", this._validateType(), !this._isTextarea && Cb().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(n) { n !== this.value && (this._inputValueAccessor.value = n, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(n) { this._readonly = mr(n) } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(n => { this.autofilled = n.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement), this._platform.IOS && this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(n) { this._elementRef.nativeElement.focus(n) } _focusChanged(n) { n !== this.focused && (this.focused = n, this.stateChanges.next()) } _onInput() { } _dirtyCheckPlaceholder() { const n = this._formField, r = n && "legacy" === n.appearance && !n._hasLabel?.() ? null : this.placeholder; if (r !== this._previousPlaceholder) { const i = this._elementRef.nativeElement; this._previousPlaceholder = r, r ? i.setAttribute("placeholder", r) : i.removeAttribute("placeholder") } } _dirtyCheckNativeValue() { const n = this._elementRef.nativeElement.value; this._previousNativeValue !== n && (this._previousNativeValue = n, this.stateChanges.next()) } _validateType() { iO.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let n = this._elementRef.nativeElement.validity; return n && n.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const n = this._elementRef.nativeElement, r = n.options[0]; return this.focused || n.multiple || !this.empty || !!(n.selectedIndex > -1 && r && r.label) } return this.focused || !this.empty } setDescribedByIds(n) { n.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", n.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } _isInlineSelect() { const n = this._elementRef.nativeElement; return this._isNativeSelect && (n.multiple || n.size > 1) } } return t.\u0275fac = function (n) { return new (n || t)(v(Ve), v(gr), v(Sn, 10), v(Ma, 8), v(Eo, 8), v(Vb), v(rO, 10), v(nO), v(ue), v(Yb, 8)) }, t.\u0275dir = N({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 12, hostBindings: function (n, r) { 1 & n && Ge("focus", function () { return r._focusChanged(!0) })("blur", function () { return r._focusChanged(!1) })("input", function () { return r._onInput() }), 2 & n && (hc("disabled", r.disabled)("required", r.required), At("id", r.id)("data-placeholder", r.placeholder)("name", r.name || null)("readonly", r.readonly && !r._isNativeSelect || null)("aria-invalid", r.empty && r.required ? null : r.errorState)("aria-required", r.required), zt("mat-input-server", r._isServer)("mat-native-select-inline", r._isInlineSelect())) }, inputs: { disabled: "disabled", id: "id", placeholder: "placeholder", name: "name", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", readonly: "readonly" }, exportAs: ["matInput"], features: [le([{ provide: jd, useExisting: t }]), Y, Jt] }), t })(), lO = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ providers: [Vb], imports: [Jb, $d, _r, Jb, $d] }), t })(); const uO = ["mat-button", ""], cO = ["*"], fO = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"], hO = Lb(lk(uk(class { constructor(t) { this._elementRef = t } }))); let pO = (() => { class t extends hO { constructor(n, r, i) { super(n), this._focusMonitor = r, this._animationMode = i, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const o of fO) this._hasHostAttributes(o) && this._getHostElement().classList.add(o); n.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(n, r) { n ? this._focusMonitor.focusVia(this._getHostElement(), n, r) : this._getHostElement().focus(r) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...n) { return n.some(r => this._getHostElement().hasAttribute(r)) } } return t.\u0275fac = function (n) { return new (n || t)(v(Ve), v(J1), v(co, 8)) }, t.\u0275cmp = Di({ type: t, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (n, r) { if (1 & n && so($b, 5), 2 & n) { let i; it(i = ot()) && (r.ripple = i.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function (n, r) { 2 & n && (At("disabled", r.disabled || null), zt("_mat-animation-noopable", "NoopAnimations" === r._animationMode)("mat-button-disabled", r.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [Y], attrs: uO, ngContentSelectors: cO, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (n, r) { 1 & n && (uc(), he(0, "span", 0), ln(1), de(), sn(2, "span", 1)(3, "span", 2)), 2 & n && (Le(2), zt("mat-button-ripple-round", r.isRoundButton || r.isIconButton), De("matRippleDisabled", r._isRippleDisabled())("matRippleCentered", r.isIconButton)("matRippleTrigger", r._getHostElement())) }, dependencies: [$b], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}.mat-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}"], encapsulation: 2, changeDetection: 0 }), t })(), mO = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ imports: [yk, _r, _r] }), t })(), Ud = (() => { class t { constructor() { this.data$ = new Mb({ firstName: "", lastName: "", company: "" }) } update(n) { this.data$.next(n) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(), gO = (() => { class t { constructor(n, r) { this.dataSerivce = n, this.cdr = r, this.form = new ba({ company: new Do(""), firstName: new Do(""), lastName: new Do("") }) } ngOnInit() { this.dataSerivce.data$.subscribe(n => { this.form.setValue(n), this.cdr.detectChanges() }) } onClick() { console.log("submitted", this.form.getRawValue()), invokeCSharpAction && invokeCSharpAction(JSON.stringify(this.form.getRawValue())) } } return t.\u0275fac = function (n) { return new (n || t)(v(Ud), v(Ks)) }, t.\u0275cmp = Di({ type: t, selectors: [["app-root"]], decls: 15, vars: 1, consts: [[1, "example-form", 3, "formGroup", "submit"], ["appearance", "fill", 1, "example-full-width"], ["matInput", "", "value", "Clario", "formControlName", "company"], ["matInput", "", "formControlName", "firstName"], ["matInput", "", "formControlName", "lastName"], ["mat-raised-button", "", "color", "primary", "type", "submit"]], template: function (n, r) { 1 & n && (he(0, "form", 0), Ge("submit", function () { return r.onClick() }), he(1, "mat-form-field", 1)(2, "mat-label"), jn(3, "Company"), de(), sn(4, "input", 2), de(), he(5, "mat-form-field", 1)(6, "mat-label"), jn(7, "First name"), de(), sn(8, "input", 3), de(), he(9, "mat-form-field", 1)(10, "mat-label"), jn(11, "Last name"), de(), sn(12, "input", 4), de(), he(13, "button", 5), jn(14, " Send data to C# "), de()()), 2 & n && De("formGroup", r.form) }, dependencies: [rb, pa, Bv, jv, Eo, Sd, tO, Hd, aO, pO], styles: [".example-form[_ngcontent-%COMP%]{margin:10px;display:flex;flex-direction:column;align-items:stretch}"] }), t })(); const q = !1; function eD(t) { return new w(3e3, q) } function YO() { return typeof window < "u" && typeof window.document < "u" } function Gd() { return typeof process < "u" && "[object process]" === {}.toString.call(process) } function qn(t) { switch (t.length) { case 0: return new To; case 1: return t[0]; default: return new Kb(t) } } function tD(t, e, n, r, i = new Map, o = new Map) { const s = [], a = []; let l = -1, u = null; if (r.forEach(c => { const d = c.get("offset"), f = d == l, h = f && u || new Map; c.forEach((p, m) => { let y = m, _ = p; if ("offset" !== m) switch (y = e.normalizePropertyName(y, s), _) { case "!": _ = i.get(m); break; case Fn: _ = o.get(m); break; default: _ = e.normalizeStyleValue(m, y, _, s) }h.set(y, _) }), f || a.push(h), u = h, l = d }), s.length) throw function BO(t) { return new w(3502, q) }(); return a } function zd(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && qd(n, "start", t))); break; case "done": t.onDone(() => r(n && qd(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && qd(n, "destroy", t))) } } function qd(t, e, n) { const o = Wd(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, n.totalTime ?? t.totalTime, !!n.disabled), s = t._data; return null != s && (o._data = s), o } function Wd(t, e, n, r, i = "", o = 0, s) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: i, totalTime: o, disabled: !!s } } function gt(t, e, n) { let r = t.get(e); return r || t.set(e, r = n), r } function nD(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.slice(e + 1)] } let Kd = (t, e) => !1, rD = (t, e, n) => [], iD = null; function Qd(t) { const e = t.parentNode || t.host; return e === iD ? null : e } (Gd() || typeof Element < "u") && (YO() ? (iD = (() => document.documentElement)(), Kd = (t, e) => { for (; e;) { if (e === t) return !0; e = Qd(e) } return !1 }) : Kd = (t, e) => t.contains(e), rD = (t, e, n) => { if (n) return Array.from(t.querySelectorAll(e)); const r = t.querySelector(e); return r ? [r] : [] }); let vr = null, oD = !1; const sD = Kd, aD = rD; let lD = (() => { class t { validateStyleProperty(n) { return function JO(t) { vr || (vr = function eP() { return typeof document < "u" ? document.body : null }() || {}, oD = !!vr.style && "WebkitAppearance" in vr.style); let e = !0; return vr.style && !function XO(t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in vr.style, !e && oD && (e = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in vr.style)), e }(n) } matchesElement(n, r) { return !1 } containsElement(n, r) { return sD(n, r) } getParentElement(n) { return Qd(n) } query(n, r, i) { return aD(n, r, i) } computeStyle(n, r, i) { return i || "" } animate(n, r, i, o, s, a = [], l) { return new To(i, o) } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(), Zd = (() => { class t { } return t.NOOP = new lD, t })(); const Yd = "ng-enter", ka = "ng-leave", Oa = "ng-trigger", Pa = ".ng-trigger", cD = "ng-animating", Xd = ".ng-animating"; function Wn(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Jd(parseFloat(e[1]), e[2]) } function Jd(t, e) { return "s" === e ? 1e3 * t : t } function Ra(t, e, n) { return t.hasOwnProperty("duration") ? t : function rP(t, e, n) { let i, o = 0, s = ""; if ("string" == typeof t) { const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return e.push(eD()), { duration: 0, delay: 0, easing: "" }; i = Jd(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (o = Jd(parseFloat(l), a[4])); const u = a[5]; u && (s = u) } else i = t; if (!n) { let a = !1, l = e.length; i < 0 && (e.push(function yO() { return new w(3100, q) }()), a = !0), o < 0 && (e.push(function _O() { return new w(3101, q) }()), a = !0), a && e.splice(l, 0, eD()) } return { duration: i, delay: o, easing: s } }(t, e, n) } function Io(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function dD(t) { const e = new Map; return Object.keys(t).forEach(n => { e.set(n, t[n]) }), e } function Kn(t, e = new Map, n) { if (n) for (let [r, i] of n) e.set(r, i); for (let [r, i] of t) e.set(r, i); return e } function hD(t, e, n) { return n ? e + ":" + n + ";" : "" } function pD(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += hD(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += hD(0, aP(n), t.style[n])); t.setAttribute("style", e) } function gn(t, e, n) { t.style && (e.forEach((r, i) => { const o = tf(i); n && !n.has(i) && n.set(i, t.style[o]), t.style[o] = r }), Gd() && pD(t)) } function br(t, e) { t.style && (e.forEach((n, r) => { const i = tf(r); t.style[i] = "" }), Gd() && pD(t)) } function So(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : qb(t) : t } const ef = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function mD(t) { let e = []; if ("string" == typeof t) { let n; for (; n = ef.exec(t);)e.push(n[1]); ef.lastIndex = 0 } return e } function La(t, e, n) { const r = t.toString(), i = r.replace(ef, (o, s) => { let a = e[s]; return null == a && (n.push(function bO(t) { return new w(3003, q) }()), a = ""), a.toString() }); return i == r ? t : i } function Va(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const sP = /-+([a-z0-9])/g; function tf(t) { return t.replace(sP, (...e) => e[1].toUpperCase()) } function aP(t) { return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function yt(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw function DO(t) { return new w(3004, q) }() } } function gD(t, e) { return window.getComputedStyle(t)[e] } function hP(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(r => function pP(t, e, n) { if (":" == t[0]) { const l = function mP(t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (n, r) => parseFloat(r) > parseFloat(n); case ":decrement": return (n, r) => parseFloat(r) < parseFloat(n); default: return e.push(function PO(t) { return new w(3016, q) }()), "* => *" } }(t, n); if ("function" == typeof l) return void e.push(l); t = l } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(function OO(t) { return new w(3015, q) }()), e; const i = r[1], o = r[2], s = r[3]; e.push(yD(i, s)); "<" == o[0] && !("*" == i && "*" == s) && e.push(yD(s, i)) }(r, n, e)) : n.push(t), n } const $a = new Set(["true", "1"]), Ua = new Set(["false", "0"]); function yD(t, e) { const n = $a.has(t) || Ua.has(t), r = $a.has(e) || Ua.has(e); return (i, o) => { let s = "*" == t || t == i, a = "*" == e || e == o; return !s && n && "boolean" == typeof i && (s = i ? $a.has(t) : Ua.has(t)), !a && r && "boolean" == typeof o && (a = o ? $a.has(e) : Ua.has(e)), s && a } } const gP = new RegExp("s*:selfs*,?", "g"); function nf(t, e, n, r) { return new yP(t).build(e, n, r) } class yP { constructor(e) { this._driver = e } build(e, n, r) { const i = new bP(n); return this._resetContextStyleTimingState(i), yt(this, So(e), i) } _resetContextStyleTimingState(e) { e.currentQuerySelector = "", e.collectedStyles = new Map, e.collectedStyles.set("", new Map), e.currentTime = 0 } visitTrigger(e, n) { let r = n.queryCount = 0, i = n.depCount = 0; const o = [], s = []; return "@" == e.name.charAt(0) && n.errors.push(function wO() { return new w(3006, q) }()), e.definitions.forEach(a => { if (this._resetContextStyleTimingState(n), 0 == a.type) { const l = a, u = l.name; u.toString().split(/\s*,\s*/).forEach(c => { l.name = c, o.push(this.visitState(l, n)) }), l.name = u } else if (1 == a.type) { const l = this.visitTransition(a, n); r += l.queryCount, i += l.depCount, s.push(l) } else n.errors.push(function CO() { return new w(3007, q) }()) }), { type: 7, name: e.name, states: o, transitions: s, queryCount: r, depCount: i, options: null } } visitState(e, n) { const r = this.visitStyle(e.styles, n), i = e.options && e.options.params || null; if (r.containsDynamicStyles) { const o = new Set, s = i || {}; r.styles.forEach(a => { a instanceof Map && a.forEach(l => { mD(l).forEach(u => { s.hasOwnProperty(u) || o.add(u) }) }) }), o.size && (Va(o.values()), n.errors.push(function MO(t, e) { return new w(3008, q) }())) } return { type: 0, name: e.name, style: r, options: i ? { params: i } : null } } visitTransition(e, n) { n.queryCount = 0, n.depCount = 0; const r = yt(this, So(e.animation), n); return { type: 1, matchers: hP(e.expr, n.errors), animation: r, queryCount: n.queryCount, depCount: n.depCount, options: Dr(e.options) } } visitSequence(e, n) { return { type: 2, steps: e.steps.map(r => yt(this, r, n)), options: Dr(e.options) } } visitGroup(e, n) { const r = n.currentTime; let i = 0; const o = e.steps.map(s => { n.currentTime = r; const a = yt(this, s, n); return i = Math.max(i, n.currentTime), a }); return n.currentTime = i, { type: 3, steps: o, options: Dr(e.options) } } visitAnimate(e, n) { const r = function EP(t, e) { if (t.hasOwnProperty("duration")) return t; if ("number" == typeof t) return rf(Ra(t, e).duration, 0, ""); const n = t; if (n.split(/\s+/).some(o => "{" == o.charAt(0) && "{" == o.charAt(1))) { const o = rf(0, 0, ""); return o.dynamic = !0, o.strValue = n, o } const i = Ra(n, e); return rf(i.duration, i.delay, i.easing) }(e.timings, n.errors); n.currentAnimateTimings = r; let i, o = e.styles ? e.styles : xa({}); if (5 == o.type) i = this.visitKeyframes(o, n); else { let s = e.styles, a = !1; if (!s) { a = !0; const u = {}; r.easing && (u.easing = r.easing), s = xa(u) } n.currentTime += r.duration + r.delay; const l = this.visitStyle(s, n); l.isEmptyStep = a, i = l } return n.currentAnimateTimings = null, { type: 4, timings: r, style: i, options: null } } visitStyle(e, n) { const r = this._makeStyleAst(e, n); return this._validateStyleAst(r, n), r } _makeStyleAst(e, n) { const r = [], i = Array.isArray(e.styles) ? e.styles : [e.styles]; for (let a of i) "string" == typeof a ? a === Fn ? r.push(a) : n.errors.push(new w(3002, q)) : r.push(dD(a)); let o = !1, s = null; return r.forEach(a => { if (a instanceof Map && (a.has("easing") && (s = a.get("easing"), a.delete("easing")), !o)) for (let l of a.values()) if (l.toString().indexOf("{{") >= 0) { o = !0; break } }), { type: 6, styles: r, easing: s, offset: e.offset, containsDynamicStyles: o, options: null } } _validateStyleAst(e, n) { const r = n.currentAnimateTimings; let i = n.currentTime, o = n.currentTime; r && o > 0 && (o -= r.duration + r.delay), e.styles.forEach(s => { "string" != typeof s && s.forEach((a, l) => { const u = n.collectedStyles.get(n.currentQuerySelector), c = u.get(l); let d = !0; c && (o != i && o >= c.startTime && i <= c.endTime && (n.errors.push(function TO(t, e, n, r, i) { return new w(3010, q) }()), d = !1), o = c.startTime), d && u.set(l, { startTime: o, endTime: i }), n.options && function oP(t, e, n) { const r = e.params || {}, i = mD(t); i.length && i.forEach(o => { r.hasOwnProperty(o) || n.push(function vO(t) { return new w(3001, q) }()) }) }(a, n.options, n.errors) }) }) } visitKeyframes(e, n) { const r = { type: 5, styles: [], options: null }; if (!n.currentAnimateTimings) return n.errors.push(function IO() { return new w(3011, q) }()), r; let o = 0; const s = []; let a = !1, l = !1, u = 0; const c = e.steps.map(_ => { const D = this._makeStyleAst(_, n); let g = null != D.offset ? D.offset : function DP(t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(n => { if (n instanceof Map && n.has("offset")) { const r = n; e = parseFloat(r.get("offset")), r.delete("offset") } }); else if (t instanceof Map && t.has("offset")) { const n = t; e = parseFloat(n.get("offset")), n.delete("offset") } return e }(D.styles), E = 0; return null != g && (o++, E = D.offset = g), l = l || E < 0 || E > 1, a = a || E < u, u = E, s.push(E), D }); l && n.errors.push(function SO() { return new w(3012, q) }()), a && n.errors.push(function FO() { return new w(3200, q) }()); const d = e.steps.length; let f = 0; o > 0 && o < d ? n.errors.push(function xO() { return new w(3202, q) }()) : 0 == o && (f = 1 / (d - 1)); const h = d - 1, p = n.currentTime, m = n.currentAnimateTimings, y = m.duration; return c.forEach((_, D) => { const g = f > 0 ? D == h ? 1 : f * D : s[D], E = g * y; n.currentTime = p + m.delay + E, m.duration = E, this._validateStyleAst(_, n), _.offset = g, r.styles.push(_) }), r } visitReference(e, n) { return { type: 8, animation: yt(this, So(e.animation), n), options: Dr(e.options) } } visitAnimateChild(e, n) { return n.depCount++, { type: 9, options: Dr(e.options) } } visitAnimateRef(e, n) { return { type: 10, animation: this.visitReference(e.animation, n), options: Dr(e.options) } } visitQuery(e, n) { const r = n.currentQuerySelector, i = e.options || {}; n.queryCount++, n.currentQuery = e; const [o, s] = function _P(t) { const e = !!t.split(/\s*,\s*/).find(n => ":self" == n); return e && (t = t.replace(gP, "")), t = t.replace(/@\*/g, Pa).replace(/@\w+/g, n => Pa + "-" + n.slice(1)).replace(/:animating/g, Xd), [t, e] }(e.selector); n.currentQuerySelector = r.length ? r + " " + o : o, gt(n.collectedStyles, n.currentQuerySelector, new Map); const a = yt(this, So(e.animation), n); return n.currentQuery = null, n.currentQuerySelector = r, { type: 11, selector: o, limit: i.limit || 0, optional: !!i.optional, includeSelf: s, animation: a, originalSelector: e.selector, options: Dr(e.options) } } visitStagger(e, n) { n.currentQuery || n.errors.push(function NO() { return new w(3013, q) }()); const r = "full" === e.timings ? { duration: 0, delay: 0, easing: "full" } : Ra(e.timings, n.errors, !0); return { type: 12, animation: yt(this, So(e.animation), n), timings: r, options: null } } } class bP { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set, this.nonAnimatableCSSPropertiesFound = new Set } } function Dr(t) { return t ? (t = Io(t)).params && (t.params = function vP(t) { return t ? Io(t) : null }(t.params)) : t = {}, t } function rf(t, e, n) { return { duration: t, delay: e, easing: n } } function of(t, e, n, r, i, o, s = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: i, delay: o, totalTime: i + o, easing: s, subTimeline: a } } class Ga { constructor() { this._map = new Map } get(e) { return this._map.get(e) || [] } append(e, n) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...n) } has(e) { return this._map.has(e) } clear() { this._map.clear() } } const MP = new RegExp(":enter", "g"), TP = new RegExp(":leave", "g"); function sf(t, e, n, r, i, o = new Map, s = new Map, a, l, u = []) { return (new IP).buildKeyframes(t, e, n, r, i, o, s, a, l, u) } class IP { buildKeyframes(e, n, r, i, o, s, a, l, u, c = []) { u = u || new Ga; const d = new af(e, n, u, i, o, c, []); d.options = l; const f = l.delay ? Wn(l.delay) : 0; d.currentTimeline.delayNextStep(f), d.currentTimeline.setStyles([s], null, d.errors, l), yt(this, r, d); const h = d.timelines.filter(p => p.containsAnimation()); if (h.length && a.size) { let p; for (let m = h.length - 1; m >= 0; m--) { const y = h[m]; if (y.element === n) { p = y; break } } p && !p.allowOnlyTimelineStyles() && p.setStyles([a], null, d.errors, l) } return h.length ? h.map(p => p.buildKeyframes()) : [of(n, [], [], [], 0, f, "", !1)] } visitTrigger(e, n) { } visitState(e, n) { } visitTransition(e, n) { } visitAnimateChild(e, n) { const r = n.subInstructions.get(n.element); if (r) { const i = n.createSubContext(e.options), o = n.currentTimeline.currentTime, s = this._visitSubInstructions(r, i, i.options); o != s && n.transformIntoNewTimeline(s) } n.previousNode = e } visitAnimateRef(e, n) { const r = n.createSubContext(e.options); r.transformIntoNewTimeline(), this.visitReference(e.animation, r), n.transformIntoNewTimeline(r.currentTimeline.currentTime), n.previousNode = e } _visitSubInstructions(e, n, r) { let o = n.currentTimeline.currentTime; const s = null != r.duration ? Wn(r.duration) : null, a = null != r.delay ? Wn(r.delay) : null; return 0 !== s && e.forEach(l => { const u = n.appendInstructionToTimeline(l, s, a); o = Math.max(o, u.duration + u.delay) }), o } visitReference(e, n) { n.updateOptions(e.options, !0), yt(this, e.animation, n), n.previousNode = e } visitSequence(e, n) { const r = n.subContextCount; let i = n; const o = e.options; if (o && (o.params || o.delay) && (i = n.createSubContext(o), i.transformIntoNewTimeline(), null != o.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = za); const s = Wn(o.delay); i.delayNextStep(s) } e.steps.length && (e.steps.forEach(s => yt(this, s, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > r && i.transformIntoNewTimeline()), n.previousNode = e } visitGroup(e, n) { const r = []; let i = n.currentTimeline.currentTime; const o = e.options && e.options.delay ? Wn(e.options.delay) : 0; e.steps.forEach(s => { const a = n.createSubContext(e.options); o && a.delayNextStep(o), yt(this, s, a), i = Math.max(i, a.currentTimeline.currentTime), r.push(a.currentTimeline) }), r.forEach(s => n.currentTimeline.mergeTimelineCollectedStyles(s)), n.transformIntoNewTimeline(i), n.previousNode = e } _visitTiming(e, n) { if (e.dynamic) { const r = e.strValue; return Ra(n.params ? La(r, n.params, n.errors) : r, n.errors) } return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, n) { const r = n.currentAnimateTimings = this._visitTiming(e.timings, n), i = n.currentTimeline; r.delay && (n.incrementTime(r.delay), i.snapshotCurrentStyles()); const o = e.style; 5 == o.type ? this.visitKeyframes(o, n) : (n.incrementTime(r.duration), this.visitStyle(o, n), i.applyStylesToKeyframe()), n.currentAnimateTimings = null, n.previousNode = e } visitStyle(e, n) { const r = n.currentTimeline, i = n.currentAnimateTimings; !i && r.hasCurrentStyleProperties() && r.forwardFrame(); const o = i && i.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(o) : r.setStyles(e.styles, o, n.errors, n.options), n.previousNode = e } visitKeyframes(e, n) { const r = n.currentAnimateTimings, i = n.currentTimeline.duration, o = r.duration, a = n.createSubContext().currentTimeline; a.easing = r.easing, e.styles.forEach(l => { a.forwardTime((l.offset || 0) * o), a.setStyles(l.styles, l.easing, n.errors, n.options), a.applyStylesToKeyframe() }), n.currentTimeline.mergeTimelineCollectedStyles(a), n.transformIntoNewTimeline(i + o), n.previousNode = e } visitQuery(e, n) { const r = n.currentTimeline.currentTime, i = e.options || {}, o = i.delay ? Wn(i.delay) : 0; o && (6 === n.previousNode.type || 0 == r && n.currentTimeline.hasCurrentStyleProperties()) && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = za); let s = r; const a = n.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!i.optional, n.errors); n.currentQueryTotal = a.length; let l = null; a.forEach((u, c) => { n.currentQueryIndex = c; const d = n.createSubContext(e.options, u); o && d.delayNextStep(o), u === n.element && (l = d.currentTimeline), yt(this, e.animation, d), d.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, d.currentTimeline.currentTime) }), n.currentQueryIndex = 0, n.currentQueryTotal = 0, n.transformIntoNewTimeline(s), l && (n.currentTimeline.mergeTimelineCollectedStyles(l), n.currentTimeline.snapshotCurrentStyles()), n.previousNode = e } visitStagger(e, n) { const r = n.parentContext, i = n.currentTimeline, o = e.timings, s = Math.abs(o.duration), a = s * (n.currentQueryTotal - 1); let l = s * n.currentQueryIndex; switch (o.duration < 0 ? "reverse" : o.easing) { case "reverse": l = a - l; break; case "full": l = r.currentStaggerTime }const c = n.currentTimeline; l && c.delayNextStep(l); const d = c.currentTime; yt(this, e.animation, n), n.previousNode = e, r.currentStaggerTime = i.currentTime - d + (i.startTime - r.currentTimeline.startTime) } } const za = {}; class af { constructor(e, n, r, i, o, s, a, l) { this._driver = e, this.element = n, this.subInstructions = r, this._enterClassName = i, this._leaveClassName = o, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = za, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new qa(this._driver, n, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, n) { if (!e) return; const r = e; let i = this.options; null != r.duration && (i.duration = Wn(r.duration)), null != r.delay && (i.delay = Wn(r.delay)); const o = r.params; if (o) { let s = i.params; s || (s = this.options.params = {}), Object.keys(o).forEach(a => { (!n || !s.hasOwnProperty(a)) && (s[a] = La(o[a], s, this.errors)) }) } } _copyOptions() { const e = {}; if (this.options) { const n = this.options.params; if (n) { const r = e.params = {}; Object.keys(n).forEach(i => { r[i] = n[i] }) } } return e } createSubContext(e = null, n, r) { const i = n || this.element, o = new af(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, r || 0)); return o.previousNode = this.previousNode, o.currentAnimateTimings = this.currentAnimateTimings, o.options = this._copyOptions(), o.updateOptions(e), o.currentQueryIndex = this.currentQueryIndex, o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this, this.subContextCount++, o } transformIntoNewTimeline(e) { return this.previousNode = za, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, n, r) { const i = { duration: n ?? e.duration, delay: this.currentTimeline.currentTime + (r ?? 0) + e.delay, easing: "" }, o = new SP(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, i, e.stretchStartingKeyframe); return this.timelines.push(o), i } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, n, r, i, o, s) { let a = []; if (i && a.push(this.element), e.length > 0) { e = (e = e.replace(MP, "." + this._enterClassName)).replace(TP, "." + this._leaveClassName); let u = this._driver.query(this.element, e, 1 != r); 0 !== r && (u = r < 0 ? u.slice(u.length + r, u.length) : u.slice(0, r)), a.push(...u) } return !o && 0 == a.length && s.push(function kO(t) { return new w(3014, q) }()), a } } class qa { constructor(e, n, r, i) { this._driver = e, this.element = n, this.startTime = r, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(n), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(n, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { const n = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || n ? (this.forwardTime(this.currentTime + e), n && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, n) { return this.applyStylesToKeyframe(), new qa(this._driver, e, n || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, n) { this._localTimelineStyles.set(e, n), this._globalTimelineStyles.set(e, n), this._styleSummary.set(e, { time: this.currentTime, value: n }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && this._previousKeyframe.set("easing", e); for (let [n, r] of this._globalTimelineStyles) this._backFill.set(n, r || Fn), this._currentKeyframe.set(n, Fn); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, n, r, i) { n && this._previousKeyframe.set("easing", n); const o = i && i.params || {}, s = function FP(t, e) { const n = new Map; let r; return t.forEach(i => { if ("*" === i) { r = r || e.keys(); for (let o of r) n.set(o, Fn) } else Kn(i, n) }), n }(e, this._globalTimelineStyles); for (let [a, l] of s) { const u = La(l, o, r); this._pendingStyles.set(a, u), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) || Fn), this._updateStyle(a, u) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((e, n) => { this._currentKeyframe.set(n, e) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, n) => { this._currentKeyframe.has(n) || this._currentKeyframe.set(n, e) })) } snapshotCurrentStyles() { for (let [e, n] of this._localTimelineStyles) this._pendingStyles.set(e, n), this._updateStyle(e, n) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const e = []; for (let n in this._currentKeyframe) e.push(n); return e } mergeTimelineCollectedStyles(e) { e._styleSummary.forEach((n, r) => { const i = this._styleSummary.get(r); (!i || n.time > i.time) && this._updateStyle(r, n.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const e = new Set, n = new Set, r = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((a, l) => { const u = Kn(a, new Map, this._backFill); u.forEach((c, d) => { "!" === c ? e.add(d) : c === Fn && n.add(d) }), r || u.set("offset", l / this.duration), i.push(u) }); const o = e.size ? Va(e.values()) : [], s = n.size ? Va(n.values()) : []; if (r) { const a = i[0], l = new Map(a); a.set("offset", 0), l.set("offset", 1), i = [a, l] } return of(this.element, i, o, s, this.duration, this.startTime, this.easing, !1) } } class SP extends qa { constructor(e, n, r, i, o, s, a = !1) { super(e, n, s.delay), this.keyframes = r, this.preStyleProps = i, this.postStyleProps = o, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: n, duration: r, easing: i } = this.timings; if (this._stretchStartingKeyframe && n) { const o = [], s = r + n, a = n / s, l = Kn(e[0]); l.set("offset", 0), o.push(l); const u = Kn(e[0]); u.set("offset", bD(a)), o.push(u); const c = e.length - 1; for (let d = 1; d <= c; d++) { let f = Kn(e[d]); const h = f.get("offset"); f.set("offset", bD((n + h * r) / s)), o.push(f) } r = s, n = 0, i = "", e = o } return of(this.element, e, this.preStyleProps, this.postStyleProps, r, n, i, !0) } } function bD(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class lf { } const xP = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class NP extends lf { normalizePropertyName(e, n) { return tf(e) } normalizeStyleValue(e, n, r, i) { let o = ""; const s = r.toString().trim(); if (xP.has(n) && 0 !== r && "0" !== r) if ("number" == typeof r) o = "px"; else { const a = r.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && i.push(function EO(t, e) { return new w(3005, q) }()) } return s + o } } function DD(t, e, n, r, i, o, s, a, l, u, c, d, f) { return { type: 0, element: t, triggerName: e, isRemovalTransition: i, fromState: n, fromStyles: o, toState: r, toStyles: s, timelines: a, queriedElements: l, preStyleProps: u, postStyleProps: c, totalTime: d, errors: f } } const uf = {}; class ED { constructor(e, n, r) { this._triggerName = e, this.ast = n, this._stateStyles = r } match(e, n, r, i) { return function kP(t, e, n, r, i) { return t.some(o => o(e, n, r, i)) }(this.ast.matchers, e, n, r, i) } buildStyles(e, n, r) { let i = this._stateStyles.get("*"); return void 0 !== e && (i = this._stateStyles.get(e?.toString()) || i), i ? i.buildStyles(n, r) : new Map } build(e, n, r, i, o, s, a, l, u, c) { const d = [], f = this.ast.options && this.ast.options.params || uf, p = this.buildStyles(r, a && a.params || uf, d), m = l && l.params || uf, y = this.buildStyles(i, m, d), _ = new Set, D = new Map, g = new Map, E = "void" === i, j = { params: OP(m, f), delay: this.ast.options?.delay }, W = c ? [] : sf(e, n, this.ast.animation, o, s, p, y, j, u, d); let me = 0; if (W.forEach(vt => { me = Math.max(vt.duration + vt.delay, me) }), d.length) return DD(n, this._triggerName, r, i, E, p, y, [], [], D, g, me, d); W.forEach(vt => { const bt = vt.element, gi = gt(D, bt, new Set); vt.preStyleProps.forEach(Zt => gi.add(Zt)); const xn = gt(g, bt, new Set); vt.postStyleProps.forEach(Zt => xn.add(Zt)), bt !== n && _.add(bt) }); const _t = Va(_.values()); return DD(n, this._triggerName, r, i, E, p, y, W, _t, D, g, me) } } function OP(t, e) { const n = Io(e); for (const r in t) t.hasOwnProperty(r) && null != t[r] && (n[r] = t[r]); return n } class PP { constructor(e, n, r) { this.styles = e, this.defaultParams = n, this.normalizer = r } buildStyles(e, n) { const r = new Map, i = Io(this.defaultParams); return Object.keys(e).forEach(o => { const s = e[o]; null !== s && (i[o] = s) }), this.styles.styles.forEach(o => { "string" != typeof o && o.forEach((s, a) => { s && (s = La(s, i, n)); const l = this.normalizer.normalizePropertyName(a, n); s = this.normalizer.normalizeStyleValue(a, l, s, n), r.set(l, s) }) }), r } } class LP { constructor(e, n, r) { this.name = e, this.ast = n, this._normalizer = r, this.transitionFactories = [], this.states = new Map, n.states.forEach(i => { this.states.set(i.name, new PP(i.style, i.options && i.options.params || {}, r)) }), wD(this.states, "true", "1"), wD(this.states, "false", "0"), n.transitions.forEach(i => { this.transitionFactories.push(new ED(e, i, this.states)) }), this.fallbackTransition = function VP(t, e, n) { return new ED(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(s, a) => !0], options: null, queryCount: 0, depCount: 0 }, e) }(e, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, n, r, i) { return this.transitionFactories.find(s => s.match(e, n, r, i)) || null } matchStyles(e, n, r) { return this.fallbackTransition.buildStyles(e, n, r) } } function wD(t, e, n) { t.has(e) ? t.has(n) || t.set(n, t.get(e)) : t.has(n) && t.set(e, t.get(n)) } const BP = new Ga; class jP { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._animations = new Map, this._playersById = new Map, this.players = [] } register(e, n) { const r = [], o = nf(this._driver, n, r, []); if (r.length) throw function jO(t) { return new w(3503, q) }(); this._animations.set(e, o) } _buildPlayer(e, n, r) { const i = e.element, o = tD(0, this._normalizer, 0, e.keyframes, n, r); return this._driver.animate(i, o, e.duration, e.delay, e.easing, [], !0) } create(e, n, r = {}) { const i = [], o = this._animations.get(e); let s; const a = new Map; if (o ? (s = sf(this._driver, n, o, Yd, ka, new Map, new Map, r, BP, i), s.forEach(c => { const d = gt(a, c.element, new Map); c.postStyleProps.forEach(f => d.set(f, null)) })) : (i.push(function HO() { return new w(3300, q) }()), s = []), i.length) throw function $O(t) { return new w(3504, q) }(); a.forEach((c, d) => { c.forEach((f, h) => { c.set(h, this._driver.computeStyle(d, h, Fn)) }) }); const u = qn(s.map(c => { const d = a.get(c.element); return this._buildPlayer(c, new Map, d) })); return this._playersById.set(e, u), u.onDestroy(() => this.destroy(e)), this.players.push(u), u } destroy(e) { const n = this._getPlayer(e); n.destroy(), this._playersById.delete(e); const r = this.players.indexOf(n); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { const n = this._playersById.get(e); if (!n) throw function UO(t) { return new w(3301, q) }(); return n } listen(e, n, r, i) { const o = Wd(n, "", "", ""); return zd(this._getPlayer(e), r, o, i), () => { } } command(e, n, r, i) { if ("register" == r) return void this.register(e, i[0]); if ("create" == r) return void this.create(e, n, i[0] || {}); const o = this._getPlayer(e); switch (r) { case "play": o.play(); break; case "pause": o.pause(); break; case "reset": o.reset(); break; case "restart": o.restart(); break; case "finish": o.finish(); break; case "init": o.init(); break; case "setPosition": o.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(e) } } } const CD = "ng-animate-queued", cf = "ng-animate-disabled", zP = [], MD = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, qP = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Ft = "__ng_removed"; class df { constructor(e, n = "") { this.namespaceId = n; const r = e && e.hasOwnProperty("value"); if (this.value = function ZP(t) { return t ?? null }(r ? e.value : e), r) { const o = Io(e); delete o.value, this.options = o } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(e) { const n = e.params; if (n) { const r = this.options.params; Object.keys(n).forEach(i => { null == r[i] && (r[i] = n[i]) }) } } } const Fo = "void", ff = new df(Fo); class WP { constructor(e, n, r) { this.id = e, this.hostElement = n, this._engine = r, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, xt(n, this._hostClassName) } listen(e, n, r, i) { if (!this._triggers.has(n)) throw function GO(t, e) { return new w(3302, q) }(); if (null == r || 0 == r.length) throw function zO(t) { return new w(3303, q) }(); if (!function YP(t) { return "start" == t || "done" == t }(r)) throw function qO(t, e) { return new w(3400, q) }(); const o = gt(this._elementListeners, e, []), s = { name: n, phase: r, callback: i }; o.push(s); const a = gt(this._engine.statesByElement, e, new Map); return a.has(n) || (xt(e, Oa), xt(e, Oa + "-" + n), a.set(n, ff)), () => { this._engine.afterFlush(() => { const l = o.indexOf(s); l >= 0 && o.splice(l, 1), this._triggers.has(n) || a.delete(n) }) } } register(e, n) { return !this._triggers.has(e) && (this._triggers.set(e, n), !0) } _getTrigger(e) { const n = this._triggers.get(e); if (!n) throw function WO(t) { return new w(3401, q) }(); return n } trigger(e, n, r, i = !0) { const o = this._getTrigger(n), s = new hf(this.id, n, e); let a = this._engine.statesByElement.get(e); a || (xt(e, Oa), xt(e, Oa + "-" + n), this._engine.statesByElement.set(e, a = new Map)); let l = a.get(n); const u = new df(r, this.id); if (!(r && r.hasOwnProperty("value")) && l && u.absorbOptions(l.options), a.set(n, u), l || (l = ff), u.value !== Fo && l.value === u.value) { if (!function eR(t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let i = 0; i < n.length; i++) { const o = n[i]; if (!e.hasOwnProperty(o) || t[o] !== e[o]) return !1 } return !0 }(l.params, u.params)) { const m = [], y = o.matchStyles(l.value, l.params, m), _ = o.matchStyles(u.value, u.params, m); m.length ? this._engine.reportError(m) : this._engine.afterFlush(() => { br(e, y), gn(e, _) }) } return } const f = gt(this._engine.playersByElement, e, []); f.forEach(m => { m.namespaceId == this.id && m.triggerName == n && m.queued && m.destroy() }); let h = o.matchTransition(l.value, u.value, e, u.params), p = !1; if (!h) { if (!i) return; h = o.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: n, transition: h, fromState: l, toState: u, player: s, isFallbackTransition: p }), p || (xt(e, CD), s.onStart(() => { mi(e, CD) })), s.onDone(() => { let m = this.players.indexOf(s); m >= 0 && this.players.splice(m, 1); const y = this._engine.playersByElement.get(e); if (y) { let _ = y.indexOf(s); _ >= 0 && y.splice(_, 1) } }), this.players.push(s), f.push(s), s } deregister(e) { this._triggers.delete(e), this._engine.statesByElement.forEach(n => n.delete(e)), this._elementListeners.forEach((n, r) => { this._elementListeners.set(r, n.filter(i => i.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); const n = this._engine.playersByElement.get(e); n && (n.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, n) { const r = this._engine.driver.query(e, Pa, !0); r.forEach(i => { if (i[Ft]) return; const o = this._engine.fetchNamespacesByElement(i); o.size ? o.forEach(s => s.triggerLeaveAnimation(i, n, !1, !0)) : this.clearElementCache(i) }), this._engine.afterFlushAnimationsDone(() => r.forEach(i => this.clearElementCache(i))) } triggerLeaveAnimation(e, n, r, i) { const o = this._engine.statesByElement.get(e), s = new Map; if (o) { const a = []; if (o.forEach((l, u) => { if (s.set(u, l.value), this._triggers.has(u)) { const c = this.trigger(e, u, Fo, i); c && a.push(c) } }), a.length) return this._engine.markElementAsRemoved(this.id, e, !0, n, s), r && qn(a).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { const n = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (n && r) { const i = new Set; n.forEach(o => { const s = o.name; if (i.has(s)) return; i.add(s); const l = this._triggers.get(s).fallbackTransition, u = r.get(s) || ff, c = new df(Fo), d = new hf(this.id, s, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: s, transition: l, fromState: u, toState: c, player: d, isFallbackTransition: !0 }) }) } } removeNode(e, n) { const r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, n), this.triggerLeaveAnimation(e, n, !0)) return; let i = !1; if (r.totalAnimations) { const o = r.players.length ? r.playersByQueriedElement.get(e) : []; if (o && o.length) i = !0; else { let s = e; for (; s = s.parentNode;)if (r.statesByElement.get(s)) { i = !0; break } } } if (this.prepareLeaveAnimationListeners(e), i) r.markElementAsRemoved(this.id, e, !1, n); else { const o = e[Ft]; (!o || o === MD) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, n)) } } insertNode(e, n) { xt(e, this._hostClassName) } drainQueuedTransitions(e) { const n = []; return this._queue.forEach(r => { const i = r.player; if (i.destroyed) return; const o = r.element, s = this._elementListeners.get(o); s && s.forEach(a => { if (a.name == r.triggerName) { const l = Wd(o, r.triggerName, r.fromState.value, r.toState.value); l._data = e, zd(r.player, a.phase, l, a.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : n.push(r) }), this._queue = [], n.sort((r, i) => { const o = r.transition.ast.depCount, s = i.transition.ast.depCount; return 0 == o || 0 == s ? o - s : this._engine.driver.containsElement(r.element, i.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(n => n.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } elementContainsData(e) { let n = !1; return this._elementListeners.has(e) && (n = !0), n = !!this._queue.find(r => r.element === e) || n, n } } class KP { constructor(e, n, r) { this.bodyNode = e, this.driver = n, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (i, o) => { } } _onRemovalComplete(e, n) { this.onRemovalComplete(e, n) } get queuedPlayers() { const e = []; return this._namespaceList.forEach(n => { n.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, n) { const r = new WP(e, n, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, n) ? this._balanceNamespaceList(r, n) : (this.newHostElements.set(n, r), this.collectEnterElement(n)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, n) { const r = this._namespaceList, i = this.namespacesByHostElement; if (r.length - 1 >= 0) { let s = !1, a = this.driver.getParentElement(n); for (; a;) { const l = i.get(a); if (l) { const u = r.indexOf(l); r.splice(u + 1, 0, e), s = !0; break } a = this.driver.getParentElement(a) } s || r.unshift(e) } else r.push(e); return i.set(n, e), e } register(e, n) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, n)), r } registerTrigger(e, n, r) { let i = this._namespaceLookup[e]; i && i.register(n, r) && this.totalAnimations++ } destroy(e, n) { if (!e) return; const r = this._fetchNamespace(e); this.afterFlush(() => { this.namespacesByHostElement.delete(r.hostElement), delete this._namespaceLookup[e]; const i = this._namespaceList.indexOf(r); i >= 0 && this._namespaceList.splice(i, 1) }), this.afterFlushAnimationsDone(() => r.destroy(n)) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { const n = new Set, r = this.statesByElement.get(e); if (r) for (let i of r.values()) if (i.namespaceId) { const o = this._fetchNamespace(i.namespaceId); o && n.add(o) } return n } trigger(e, n, r, i) { if (Wa(n)) { const o = this._fetchNamespace(e); if (o) return o.trigger(n, r, i), !0 } return !1 } insertNode(e, n, r, i) { if (!Wa(n)) return; const o = n[Ft]; if (o && o.setForRemoval) { o.setForRemoval = !1, o.setForMove = !0; const s = this.collectedLeaveElements.indexOf(n); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (e) { const s = this._fetchNamespace(e); s && s.insertNode(n, r) } i && this.collectEnterElement(n) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, n) { n ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), xt(e, cf)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), mi(e, cf)) } removeNode(e, n, r, i) { if (Wa(n)) { const o = e ? this._fetchNamespace(e) : null; if (o ? o.removeNode(n, i) : this.markElementAsRemoved(e, n, !1, i), r) { const s = this.namespacesByHostElement.get(n); s && s.id !== e && s.removeNode(n, i) } } else this._onRemovalComplete(n, i) } markElementAsRemoved(e, n, r, i, o) { this.collectedLeaveElements.push(n), n[Ft] = { namespaceId: e, setForRemoval: i, hasAnimation: r, removedBeforeQueried: !1, previousTriggersValues: o } } listen(e, n, r, i, o) { return Wa(n) ? this._fetchNamespace(e).listen(n, r, i, o) : () => { } } _buildInstruction(e, n, r, i, o) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, i, e.fromState.options, e.toState.options, n, o) } destroyInnerAnimations(e) { let n = this.driver.query(e, Pa, !0); n.forEach(r => this.destroyActiveAnimationsForElement(r)), 0 != this.playersByQueriedElement.size && (n = this.driver.query(e, Xd, !0), n.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { const n = this.playersByElement.get(e); n && n.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { const n = this.playersByQueriedElement.get(e); n && n.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return qn(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { const n = e[Ft]; if (n && n.setForRemoval) { if (e[Ft] = MD, n.namespaceId) { this.destroyInnerAnimations(e); const r = this._fetchNamespace(n.namespaceId); r && r.clearElementCache(e) } this._onRemovalComplete(e, n.setForRemoval) } e.classList?.contains(cf) && this.markElementAsDisabled(e, !1), this.driver.query(e, ".ng-animate-disabled", !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(e = -1) { let n = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, i) => this._balanceNamespaceList(r, i)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++)xt(this.collectedEnterElements[r], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const r = []; try { n = this._flushAnimations(r, e) } finally { for (let i = 0; i < r.length; i++)r[i]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++)this.processLeaveNode(this.collectedLeaveElements[r]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { const r = this._whenQuietFns; this._whenQuietFns = [], n.length ? qn(n).onDone(() => { r.forEach(i => i()) }) : r.forEach(i => i()) } } reportError(e) { throw function KO(t) { return new w(3402, q) }() } _flushAnimations(e, n) { const r = new Ga, i = [], o = new Map, s = [], a = new Map, l = new Map, u = new Map, c = new Set; this.disabledNodes.forEach(T => { c.add(T); const F = this.driver.query(T, ".ng-animate-queued", !0); for (let O = 0; O < F.length; O++)c.add(F[O]) }); const d = this.bodyNode, f = Array.from(this.statesByElement.keys()), h = ID(f, this.collectedEnterElements), p = new Map; let m = 0; h.forEach((T, F) => { const O = Yd + m++; p.set(F, O), T.forEach(Q => xt(Q, O)) }); const y = [], _ = new Set, D = new Set; for (let T = 0; T < this.collectedLeaveElements.length; T++) { const F = this.collectedLeaveElements[T], O = F[Ft]; O && O.setForRemoval && (y.push(F), _.add(F), O.hasAnimation ? this.driver.query(F, ".ng-star-inserted", !0).forEach(Q => _.add(Q)) : D.add(F)) } const g = new Map, E = ID(f, Array.from(_)); E.forEach((T, F) => { const O = ka + m++; g.set(F, O), T.forEach(Q => xt(Q, O)) }), e.push(() => { h.forEach((T, F) => { const O = p.get(F); T.forEach(Q => mi(Q, O)) }), E.forEach((T, F) => { const O = g.get(F); T.forEach(Q => mi(Q, O)) }), y.forEach(T => { this.processLeaveNode(T) }) }); const j = [], W = []; for (let T = this._namespaceList.length - 1; T >= 0; T--)this._namespaceList[T].drainQueuedTransitions(n).forEach(O => { const Q = O.player, Oe = O.element; if (j.push(Q), this.collectedEnterElements.length) { const qe = Oe[Ft]; if (qe && qe.setForMove) { if (qe.previousTriggersValues && qe.previousTriggersValues.has(O.triggerName)) { const Er = qe.previousTriggersValues.get(O.triggerName), Nt = this.statesByElement.get(O.element); if (Nt && Nt.has(O.triggerName)) { const Za = Nt.get(O.triggerName); Za.value = Er, Nt.set(O.triggerName, Za) } } return void Q.destroy() } } const yn = !d || !this.driver.containsElement(d, Oe), Dt = g.get(Oe), Qn = p.get(Oe), ge = this._buildInstruction(O, r, Qn, Dt, yn); if (ge.errors && ge.errors.length) return void W.push(ge); if (yn) return Q.onStart(() => br(Oe, ge.fromStyles)), Q.onDestroy(() => gn(Oe, ge.toStyles)), void i.push(Q); if (O.isFallbackTransition) return Q.onStart(() => br(Oe, ge.fromStyles)), Q.onDestroy(() => gn(Oe, ge.toStyles)), void i.push(Q); const VD = []; ge.timelines.forEach(qe => { qe.stretchStartingKeyframe = !0, this.disabledNodes.has(qe.element) || VD.push(qe) }), ge.timelines = VD, r.append(Oe, ge.timelines), s.push({ instruction: ge, player: Q, element: Oe }), ge.queriedElements.forEach(qe => gt(a, qe, []).push(Q)), ge.preStyleProps.forEach((qe, Er) => { if (qe.size) { let Nt = l.get(Er); Nt || l.set(Er, Nt = new Set), qe.forEach((Za, mf) => Nt.add(mf)) } }), ge.postStyleProps.forEach((qe, Er) => { let Nt = u.get(Er); Nt || u.set(Er, Nt = new Set), qe.forEach((Za, mf) => Nt.add(mf)) }) }); if (W.length) { const T = []; W.forEach(F => { T.push(function QO(t, e) { return new w(3505, q) }()) }), j.forEach(F => F.destroy()), this.reportError(T) } const me = new Map, _t = new Map; s.forEach(T => { const F = T.element; r.has(F) && (_t.set(F, F), this._beforeAnimationBuild(T.player.namespaceId, T.instruction, me)) }), i.forEach(T => { const F = T.element; this._getPreviousPlayers(F, !1, T.namespaceId, T.triggerName, null).forEach(Q => { gt(me, F, []).push(Q), Q.destroy() }) }); const vt = y.filter(T => FD(T, l, u)), bt = new Map; TD(bt, this.driver, D, u, Fn).forEach(T => { FD(T, l, u) && vt.push(T) }); const xn = new Map; h.forEach((T, F) => { TD(xn, this.driver, new Set(T), l, "!") }), vt.forEach(T => { const F = bt.get(T), O = xn.get(T); bt.set(T, new Map([...Array.from(F?.entries() ?? []), ...Array.from(O?.entries() ?? [])])) }); const Zt = [], yi = [], _i = {}; s.forEach(T => { const { element: F, player: O, instruction: Q } = T; if (r.has(F)) { if (c.has(F)) return O.onDestroy(() => gn(F, Q.toStyles)), O.disabled = !0, O.overrideTotalTime(Q.totalTime), void i.push(O); let Oe = _i; if (_t.size > 1) { let Dt = F; const Qn = []; for (; Dt = Dt.parentNode;) { const ge = _t.get(Dt); if (ge) { Oe = ge; break } Qn.push(Dt) } Qn.forEach(ge => _t.set(ge, Oe)) } const yn = this._buildAnimation(O.namespaceId, Q, me, o, xn, bt); if (O.setRealPlayer(yn), Oe === _i) Zt.push(O); else { const Dt = this.playersByElement.get(Oe); Dt && Dt.length && (O.parentPlayer = qn(Dt)), i.push(O) } } else br(F, Q.fromStyles), O.onDestroy(() => gn(F, Q.toStyles)), yi.push(O), c.has(F) && i.push(O) }), yi.forEach(T => { const F = o.get(T.element); if (F && F.length) { const O = qn(F); T.setRealPlayer(O) } }), i.forEach(T => { T.parentPlayer ? T.syncPlayerEvents(T.parentPlayer) : T.destroy() }); for (let T = 0; T < y.length; T++) { const F = y[T], O = F[Ft]; if (mi(F, ka), O && O.hasAnimation) continue; let Q = []; if (a.size) { let yn = a.get(F); yn && yn.length && Q.push(...yn); let Dt = this.driver.query(F, Xd, !0); for (let Qn = 0; Qn < Dt.length; Qn++) { let ge = a.get(Dt[Qn]); ge && ge.length && Q.push(...ge) } } const Oe = Q.filter(yn => !yn.destroyed); Oe.length ? XP(this, F, Oe) : this.processLeaveNode(F) } return y.length = 0, Zt.forEach(T => { this.players.push(T), T.onDone(() => { T.destroy(); const F = this.players.indexOf(T); this.players.splice(F, 1) }), T.play() }), Zt } elementContainsData(e, n) { let r = !1; const i = n[Ft]; return i && i.setForRemoval && (r = !0), this.playersByElement.has(n) && (r = !0), this.playersByQueriedElement.has(n) && (r = !0), this.statesByElement.has(n) && (r = !0), this._fetchNamespace(e).elementContainsData(n) || r } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, n, r, i, o) { let s = []; if (n) { const a = this.playersByQueriedElement.get(e); a && (s = a) } else { const a = this.playersByElement.get(e); if (a) { const l = !o || o == Fo; a.forEach(u => { u.queued || !l && u.triggerName != i || s.push(u) }) } } return (r || i) && (s = s.filter(a => !(r && r != a.namespaceId || i && i != a.triggerName))), s } _beforeAnimationBuild(e, n, r) { const o = n.element, s = n.isRemovalTransition ? void 0 : e, a = n.isRemovalTransition ? void 0 : n.triggerName; for (const l of n.timelines) { const u = l.element, c = u !== o, d = gt(r, u, []); this._getPreviousPlayers(u, c, s, a, n.toState).forEach(h => { const p = h.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), h.destroy(), d.push(h) }) } br(o, n.fromStyles) } _buildAnimation(e, n, r, i, o, s) { const a = n.triggerName, l = n.element, u = [], c = new Set, d = new Set, f = n.timelines.map(p => { const m = p.element; c.add(m); const y = m[Ft]; if (y && y.removedBeforeQueried) return new To(p.duration, p.delay); const _ = m !== l, D = function JP(t) { const e = []; return SD(t, e), e }((r.get(m) || zP).map(me => me.getRealPlayer())).filter(me => !!me.element && me.element === m), g = o.get(m), E = s.get(m), j = tD(0, this._normalizer, 0, p.keyframes, g, E), W = this._buildPlayer(p, j, D); if (p.subTimeline && i && d.add(m), _) { const me = new hf(e, a, m); me.setRealPlayer(W), u.push(me) } return W }); u.forEach(p => { gt(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function QP(t, e, n) { let r = t.get(e); if (r) { if (r.length) { const i = r.indexOf(n); r.splice(i, 1) } 0 == r.length && t.delete(e) } return r }(this.playersByQueriedElement, p.element, p)) }), c.forEach(p => xt(p, cD)); const h = qn(f); return h.onDestroy(() => { c.forEach(p => mi(p, cD)), gn(l, n.toStyles) }), d.forEach(p => { gt(i, p, []).push(h) }), h } _buildPlayer(e, n, r) { return n.length > 0 ? this.driver.animate(e.element, n, e.duration, e.delay, e.easing, r) : new To(e.duration, e.delay) } } class hf { constructor(e, n, r) { this.namespaceId = e, this.triggerName = n, this.element = r, this._player = new To, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((n, r) => { n.forEach(i => zd(e, r, void 0, i)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { const n = this._player; n.triggerCallback && e.onStart(() => n.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, n) { gt(this._queuedCallbacks, e, []).push(n) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { const n = this._player; n.triggerCallback && n.triggerCallback(e) } } function Wa(t) { return t && 1 === t.nodeType } function AD(t, e) { const n = t.style.display; return t.style.display = e ?? "none", n } function TD(t, e, n, r, i) { const o = []; n.forEach(l => o.push(AD(l))); const s = []; r.forEach((l, u) => { const c = new Map; l.forEach(d => { const f = e.computeStyle(u, d, i); c.set(d, f), (!f || 0 == f.length) && (u[Ft] = qP, s.push(u)) }), t.set(u, c) }); let a = 0; return n.forEach(l => AD(l, o[a++])), s } function ID(t, e) { const n = new Map; if (t.forEach(a => n.set(a, [])), 0 == e.length) return n; const i = new Set(e), o = new Map; function s(a) { if (!a) return 1; let l = o.get(a); if (l) return l; const u = a.parentNode; return l = n.has(u) ? u : i.has(u) ? 1 : s(u), o.set(a, l), l } return e.forEach(a => { const l = s(a); 1 !== l && n.get(l).push(a) }), n } function xt(t, e) { t.classList?.add(e) } function mi(t, e) { t.classList?.remove(e) } function XP(t, e, n) { qn(n).onDone(() => t.processLeaveNode(e)) } function SD(t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; r instanceof Kb ? SD(r.players, e) : e.push(r) } } function FD(t, e, n) { const r = n.get(t); if (!r) return !1; let i = e.get(t); return i ? r.forEach(o => i.add(o)) : e.set(t, r), n.delete(t), !0 } class Ka { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (i, o) => { }, this._transitionEngine = new KP(e, n, r), this._timelineEngine = new jP(e, n, r), this._transitionEngine.onRemovalComplete = (i, o) => this.onRemovalComplete(i, o) } registerTrigger(e, n, r, i, o) { const s = e + "-" + i; let a = this._triggerCache[s]; if (!a) { const l = [], c = nf(this._driver, o, l, []); if (l.length) throw function VO(t, e) { return new w(3404, q) }(); a = function RP(t, e, n) { return new LP(t, e, n) }(i, c, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(n, i, a) } register(e, n) { this._transitionEngine.register(e, n) } destroy(e, n) { this._transitionEngine.destroy(e, n) } onInsert(e, n, r, i) { this._transitionEngine.insertNode(e, n, r, i) } onRemove(e, n, r, i) { this._transitionEngine.removeNode(e, n, i || !1, r) } disableAnimations(e, n) { this._transitionEngine.markElementAsDisabled(e, n) } process(e, n, r, i) { if ("@" == r.charAt(0)) { const [o, s] = nD(r); this._timelineEngine.command(o, n, s, i) } else this._transitionEngine.trigger(e, n, r, i) } listen(e, n, r, i, o) { if ("@" == r.charAt(0)) { const [s, a] = nD(r); return this._timelineEngine.listen(s, n, a, o) } return this._transitionEngine.listen(e, n, r, i, o) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } let nR = (() => { class t { constructor(n, r, i) { this._element = n, this._startStyles = r, this._endStyles = i, this._state = 0; let o = t.initialStylesByElement.get(n); o || t.initialStylesByElement.set(n, o = new Map), this._initialStyles = o } start() { this._state < 1 && (this._startStyles && gn(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (gn(this._element, this._initialStyles), this._endStyles && (gn(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (br(this._element, this._startStyles), this._endStyles = null), this._endStyles && (br(this._element, this._endStyles), this._endStyles = null), gn(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function pf(t) { let e = null; return t.forEach((n, r) => { (function rR(t) { return "display" === t || "position" === t })(r) && (e = e || new Map, e.set(r, n)) }), e } class xD { constructor(e, n, r, i) { this.element = e, this.keyframes = n, this.options = r, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(e) { const n = []; return e.forEach(r => { n.push(Object.fromEntries(r)) }), n } _triggerWebAnimation(e, n, r) { return e.animate(this._convertKeyframesToObject(n), r) } onStart(e) { this._onStartFns.push(e) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const e = new Map; this.hasStarted() && this._finalKeyframe.forEach((r, i) => { "offset" !== i && e.set(i, this._finished ? r : gD(this.element, i)) }), this.currentSnapshot = e } triggerCallback(e) { const n = "start" === e ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } } class iR { validateStyleProperty(e) { return !0 } validateAnimatableStyleProperty(e) { return !0 } matchesElement(e, n) { return !1 } containsElement(e, n) { return sD(e, n) } getParentElement(e) { return Qd(e) } query(e, n, r) { return aD(e, n, r) } computeStyle(e, n, r) { return window.getComputedStyle(e)[n] } animate(e, n, r, i, o, s = []) { const l = { duration: r, delay: i, fill: 0 == i ? "both" : "forwards" }; o && (l.easing = o); const u = new Map, c = s.filter(h => h instanceof xD); (function lP(t, e) { return 0 === t || 0 === e })(r, i) && c.forEach(h => { h.currentSnapshot.forEach((p, m) => u.set(m, p)) }); let d = function iP(t) { return t.length ? t[0] instanceof Map ? t : t.map(e => dD(e)) : [] }(n).map(h => Kn(h)); d = function uP(t, e, n) { if (n.size && e.length) { let r = e[0], i = []; if (n.forEach((o, s) => { r.has(s) || i.push(s), r.set(s, o) }), i.length) for (let o = 1; o < e.length; o++) { let s = e[o]; i.forEach(a => s.set(a, gD(t, a))) } } return e }(e, d, u); const f = function tR(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = pf(e[0]), e.length > 1 && (r = pf(e[e.length - 1]))) : e instanceof Map && (n = pf(e)), n || r ? new nR(t, n, r) : null }(e, d); return new xD(e, d, l, f) } } let oR = (() => { class t extends zb { constructor(n, r) { super(), this._nextAnimationId = 0, this._renderer = n.createRenderer(r.body, { id: "0", encapsulation: Lt.None, styles: [], data: { animation: [] } }) } build(n) { const r = this._nextAnimationId.toString(); this._nextAnimationId++; const i = Array.isArray(n) ? qb(n) : n; return ND(this._renderer, null, r, "register", [i]), new sR(r, this._renderer) } } return t.\u0275fac = function (n) { return new (n || t)(S(no), S(Be)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); class sR extends class Mk { }{ constructor(e, n) { super(), this._id = e, this._renderer = n } create(e, n) { return new aR(this._id, e, n || {}, this._renderer) } } class aR { constructor(e, n, r, i) { this.id = e, this.element = n, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r) } _listen(e, n) { return this._renderer.listen(this.element, `@@${this.id}:${e}`, n) } _command(e, ...n) { return ND(this._renderer, this.element, this.id, e, n) } onDone(e) { this._listen("done", e) } onStart(e) { this._listen("start", e) } onDestroy(e) { this._listen("destroy", e) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(e) { this._command("setPosition", e) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function ND(t, e, n, r, i) { return t.setProperty(e, `@@${n}:${r}`, i) } const kD = "@.disabled"; let lR = (() => { class t { constructor(n, r, i) { this.delegate = n, this.engine = r, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), r.onRemovalComplete = (o, s) => { const a = s?.parentNode(o); a && s.removeChild(a, o) } } createRenderer(n, r) { const o = this.delegate.createRenderer(n, r); if (!(n && r && r.data && r.data.animation)) { let c = this._rendererCache.get(o); return c || (c = new OD("", o, this.engine), this._rendererCache.set(o, c)), c } const s = r.id, a = r.id + "-" + this._currentId; this._currentId++, this.engine.register(a, n); const l = c => { Array.isArray(c) ? c.forEach(l) : this.engine.registerTrigger(s, a, n, c.name, c) }; return r.data.animation.forEach(l), new uR(this, a, o, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(n, r, i) { n >= 0 && n < this._microtaskId ? this._zone.run(() => r(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(o => { const [s, a] = o; s(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([r, i])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (n) { return new (n || t)(S(no), S(Ka), S(ue)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })(); class OD { constructor(e, n, r) { this.namespaceId = e, this.delegate = n, this.engine = r, this.destroyNode = this.delegate.destroyNode ? i => n.destroyNode(i) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(e, n) { return this.delegate.createElement(e, n) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, n) { this.delegate.appendChild(e, n), this.engine.onInsert(this.namespaceId, n, e, !1) } insertBefore(e, n, r, i = !0) { this.delegate.insertBefore(e, n, r), this.engine.onInsert(this.namespaceId, n, e, i) } removeChild(e, n, r) { this.engine.onRemove(this.namespaceId, n, this.delegate, r) } selectRootElement(e, n) { return this.delegate.selectRootElement(e, n) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, n, r, i) { this.delegate.setAttribute(e, n, r, i) } removeAttribute(e, n, r) { this.delegate.removeAttribute(e, n, r) } addClass(e, n) { this.delegate.addClass(e, n) } removeClass(e, n) { this.delegate.removeClass(e, n) } setStyle(e, n, r, i) { this.delegate.setStyle(e, n, r, i) } removeStyle(e, n, r) { this.delegate.removeStyle(e, n, r) } setProperty(e, n, r) { "@" == n.charAt(0) && n == kD ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, n, r) } setValue(e, n) { this.delegate.setValue(e, n) } listen(e, n, r) { return this.delegate.listen(e, n, r) } disableAnimations(e, n) { this.engine.disableAnimations(e, n) } } class uR extends OD { constructor(e, n, r, i) { super(n, r, i), this.factory = e, this.namespaceId = n } setProperty(e, n, r) { "@" == n.charAt(0) ? "." == n.charAt(1) && n == kD ? this.disableAnimations(e, r = void 0 === r || !!r) : this.engine.process(this.namespaceId, e, n.slice(1), r) : this.delegate.setProperty(e, n, r) } listen(e, n, r) { if ("@" == n.charAt(0)) { const i = function cR(t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(e); let o = n.slice(1), s = ""; return "@" != o.charAt(0) && ([o, s] = function dR(t) { const e = t.indexOf("."); return [t.substring(0, e), t.slice(e + 1)] }(o)), this.engine.listen(this.namespaceId, i, o, s, a => { this.factory.scheduleListenerCallback(a._data || -1, r, a) }) } return this.delegate.listen(e, n, r) } } const PD = [{ provide: zb, useClass: oR }, { provide: lf, useFactory: function hR() { return new NP } }, { provide: Ka, useClass: (() => { class t extends Ka { constructor(n, r, i) { super(n.body, r, i) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (n) { return new (n || t)(S(Be), S(Zd), S(lf)) }, t.\u0275prov = G({ token: t, factory: t.\u0275fac }), t })() }, { provide: no, useFactory: function pR(t, e, n) { return new lR(t, e, n) }, deps: [ha, Ka, ue] }], RD = [{ provide: Zd, useFactory: () => new iR }, { provide: co, useValue: "BrowserAnimations" }, ...PD], mR = [{ provide: Zd, useClass: lD }, { provide: co, useValue: "NoopAnimations" }, ...PD]; let gR = (() => { class t { static withConfig(n) { return { ngModule: t, providers: n.disableAnimations ? mR : RD } } } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t }), t.\u0275inj = xe({ providers: RD, imports: [cv] }), t })(); const LD = new Ud; window.updatetextonwebview = t => LD.update(JSON.parse(t)); let yR = (() => { class t { } return t.\u0275fac = function (n) { return new (n || t) }, t.\u0275mod = Re({ type: t, bootstrap: [gO] }), t.\u0275inj = xe({ providers: [{ provide: Ud, useValue: LD }], imports: [cv, p1, $d, gR, lO, mO] }), t })(); (function VS() { v_ = !1 })(), Zx().bootstrapModule(yR).catch(t => console.error(t)) } }, ee => { ee(ee.s = 969) }]);